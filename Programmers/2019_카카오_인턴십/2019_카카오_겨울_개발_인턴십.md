# 2019 카카오 겨울 개발 인턴십 (1차 회고)

백준에서 풀 때 항상 1초당 계산 2천만번을 limit으로 하고 풀어서 뭔가 그 안에 풀어야 한다는 생각에 사로잡혀있었는데, 그럴 필요가 없다.

효율성 풀이가 아니면 (효율성 풀이일지라도) 백준과는 다르다. 예를 들어 5번 호텔 문제의 경우 무조건 최대 20만개의 rooms에 대해 in 연산을 수행하는것은 불가피하므로, 감안해야 한다. 효율적인 방법을 고민하되 횟수를 백준처럼 세지는 말 것.



## 1. 크레인 인형뽑기 게임

20분? 남짓 걸렸다. 쉬운 문제였는데 변수설정이랑 반복문 loop 범위에서 계속 실수해서 디버깅에 한 5분 걸렸음. 반성

## 2. 튜플

1시간정도 걸린 것 같다. 로직은 바로 생각났는데, **문자열 파싱에서 삽질**해서 오래 걸렸다. 불필요하게 삽질하는 것 같다면, 뭔가 잘못 풀고 있다는 얘기!

문자열 파싱을 하나 하나 안하고, 조금 더 효율적으로 할 수 있는 방법은 없으려나? 해서 풀이를 찾아봤다.

그리고 내가 바보였음을 깨달아따. 서로 다른 집합이 `},{` 으로 구분되어 있으므로, 그걸 기준으로 나누면 된다. 허허허...

```python
S = S[2:-2].split("},{")
```

바보같았네. 다음부턴 실수하지 말자

참고로 collections에 Counter 클래스가 유용하게 쓰일 수 있는 것 같다. [참고](https://www.daleseo.com/python-collections-counter/)

## 3. 불량 사용자

오히려 2번보다 빨리 풀었다. 보자마자 트리 구조가 생각났고, 주어진 제한의 크기가 크지 않아서 완전탐색으로 풀면 될 것 같았다.

확실히 **함수를 나눠서 짜니까** 생각하기가 편했고, 다만 dfs를 어떻게 구성해야 할 지 잠깐 고민했다. Backtracking으로 가지치기하면서 풀었다. 

## 4. 징검다리 건너기

알고 나니 쉬운 문제. 이분탐색의 시간복잡도는 nlogn이다. 근데 솔직히 처음에 푼 방법이 왜 틀렸는지 아직 잘 모르겠다. 

[처음 푼 방법 참고 링크]([https://inspirit941.tistory.com/entry/Python-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-2019-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EA%B2%A8%EC%9A%B8-%EC%9D%B8%ED%84%B4-recruit-%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC-%EA%B1%B4%EB%84%88%EA%B8%B0-Level-3?category=859228](https://inspirit941.tistory.com/entry/Python-프로그래머스-2019-카카오-겨울-인턴-recruit-징검다리-건너기-Level-3?category=859228)) 연속되는 최소값이 n개 이상....뭐 그런식으로 풀었는데 시간초과 떴당. 나중에 왜 떴는지 물어봐야지.

max limit이 크니, 최적값을 찾기 위해 이분탐색을 활용하는 것이 가장 효율적인가봄.

처음에 풀 때 mid 값에 따라 건널수 있냐, 없냐가 아닌, target (k) 보다 작냐, 같냐, 크냐로 풀었는데 (계속 틀리더라. 왠지 모르겠음) 그럴 필요가 없었던 것 같다.

어차피 건널수 없으면 gap이 k보다 큰 것이므로 mid값을 줄여야하는거고, 건널 수 있으면 gap을 키워보면 되기 때문이다.

단순하게 생각해보는 것도 중요해.

## 5. 호텔 방 배정

일단 이걸 보고 union-find가 생각이 안났음. Union-find 문제를 많이 안풀어봐서 그런 것 같다.
여러개 거쳐거쳐가는 것이 아니라 path compression을 써야 한다는 희미한 생각과 dictionary를 써야 한다는 희미한 생각 정도?

Union-find를 안다면 쉽게 풀수 있었던 문제인듯.

재귀 써서 풀때는 항상 안전빵으로 sys.setrecursionlimit을 해줘야 하는 것 같다.