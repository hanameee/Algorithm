# ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜

í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ë‘ í•´ì»¤ë­í¬ í’€ê¸° ì „, ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ ë³µìŠµ ë¨¼ì €.

## 1. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì´ë€?

- ìµœì ì˜ í•´ì— ê°€ê¹Œìš´ ê°’ì„ êµ¬í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë¨
- ì—¬ëŸ¬ ê²½ìš° ì¤‘ í•˜ë‚˜ë¥¼ ê²°ì •í•´ì•¼í•  ë•Œë§ˆë‹¤, (ì—¬ëŸ¬ ì¡°í•©ì„ ìƒê°í•˜ì§€ ì•Šê³ ) **ë§¤ìˆœê°„ ìµœì ì´ë¼ê³  ìƒê°ë˜ëŠ” ê²½ìš°ë¥¼ ì„ íƒ**í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì§„í–‰í•´ì„œ, ìµœì¢…ì ì¸ ê°’ì„ êµ¬í•˜ëŠ” ë°©ì‹

## 2. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ ëŒ€í‘œì ì¸ ì˜ˆì‹œ

### 1. ë™ì „ ë¬¸ì œ

í° ë‹¨ìœ„ì˜ ë™ì „ë¶€í„° ëª«ì„ ê³„ì‚°í•˜ê¸°

### 2. ë¶€ë¶„ ë°°ë‚­ ë¬¸ì œ

ìª¼ê°¤ ìˆ˜ ìˆëŠ” Fractional Knapsack Problemì€ ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜, ìª¼ê°¤ ìˆ˜ ì—†ëŠ” 0/1 Knapsack Problemì€ ë™ì ê³„íšë²•ìœ¼ë¡œ í’€ ìˆ˜ ìˆë‹¤.

## 3. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ í•œê³„

- íƒìš• ì•Œê³ ë¦¬ì¦˜ì€ ë°˜ë“œì‹œ ìµœì ì˜ í•´ë¥¼ guarantee í•˜ëŠ” ê²ƒì€ ì•„ë‹ˆê¸°ì—, **ê·¼ì‚¬ì¹˜ ì¶”ì •**ì— í™œìš©í•œë‹¤
- ìµœì ì˜ í•´ì— ê°€ê¹Œìš´ ê°’ì„ êµ¬í•˜ëŠ” ë°©ë²• ì¤‘ì˜ í•˜ë‚˜ì„



---



## í° ìˆ˜ ë§Œë“¤ê¸°

í˜„ì¬ index ë¥¼ ê¸°ì–µí•´ íƒìƒ‰ ë²”ìœ„ë¥¼ ì¤„ì´ë©´ì„œ max ì—°ì‚°ì„ ë§¤ë²ˆ í•˜ëŠ” ì‹ìœ¼ë¡œ ì½”ë“œë¥¼ ì§°ë”ë‹ˆ test case í•˜ë‚˜ì—ì„œ ê³„ì† ì‹œê°„ ì´ˆê³¼ê°€ ë‚¬ë‹¤.

í•´ê²° ë°©ë²•ì€ **minHeap**! ìµœì†Ÿê°’, ìµœëŒ€ê°’ì„ ë°˜ë³µì ìœ¼ë¡œ êµ¬í•´ì•¼ í•  ë•ŒëŠ” í•­ìƒ **í™ êµ¬ì¡°ë¥¼ ìƒê°**í•´ì•¼ í•¨ì„ ë‹¤ì‹œ í•œë²ˆ ëª…ì‹¬.

```python
import heapq


def solution(number, k):
    number = list(map(int, list(str(number))))
    n = len(number)
    answer = ""
    minHeap = []
    for idx in range(0, k+1):
        heapq.heappush(minHeap, [-number[idx], idx])
    num, num_idx = heapq.heappop(minHeap)
    answer += str(-num)
    max_idx = num_idx
    for i in range(1, n-k):
        heapq.heappush(minHeap, [-number[k+i], k+i])
        while len(minHeap):
            num, num_idx = heapq.heappop(minHeap)
            if num_idx > max_idx:
                answer += str(-num)
                max_idx = num_idx
                break
    return answer
```



## ì¡°ì´ìŠ¤í‹±

ì–´ë ¤ì› ë‹¤ğŸ˜¡ Level 2 ë§ì•„? ì‰¬ìµì‰¬ìµ... ì‚¬ì‹¤ ì•„ì§ë„ ë§ê²Œ í’€ì—ˆëŠ”ì§€ ì˜ ëª¨ë¥´ê² ëŠ” ë¬¸ì œë‹¤.

ì²˜ìŒì—ëŠ” ì—°ì†ëœ ê°€ì¥ ê¸´ Aë¥¼ ì°¾ëŠ” ë°©ì‹ìœ¼ë¡œ í’€ì—ˆëŠ”ë°, ê·¸ë ‡ê²Œ í’€ë©´ ì¤‘ê°„ì— ë°©í–¥ì„ ë°”ê¾¸ëŠ” (ì •ë°©í–¥ > ì—­ë°©í–¥ ë˜ëŠ” ì—­ë°©í–¥ > ì •ë°©í–¥) ì„ ì»¤ë²„í•˜ì§€ ëª»í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, `BAABBAAAAAACCA` ëŠ” 5ë²ˆì§¸ Bê¹Œì§€ ì •ë°©í–¥ìœ¼ë¡œ ì§„í–‰í•œ í›„, ì—­ë°©í–¥ìœ¼ë¡œ ë°”ê¿” -2ë²ˆì§¸ Cë¡œ ê°€ëŠ”ê²Œ ìµœë‹¨ì´ë‹¤.

ì¡°ê¸ˆë§Œ ê¹Šê²Œ ìƒê°í•´ë³´ë©´ ì•„ì£¼ ë§ì€ ì½”ë„ˆì¼€ì´ìŠ¤ë“¤ì´ ìˆê¸°ì—, ë¬¸ì œì—ì„œ inputì´ 20ìœ¼ë¡œ ì•„ì£¼ ì‘ìœ¼ë¯€ë¡œ ê·¸ëƒ¥ ê·¸ë¦¬ë”” + ì™„ì „íƒìƒ‰ìœ¼ë¡œ í’€ì—ˆë‹¤.

```python
import string


# ìƒí•˜ ì¡°ì´ìŠ¤í‹± íšŸìˆ˜ ì„¸ê¸°
def calculate_vertical(alphabet):
    alphabets = string.ascii_uppercase
    return min(alphabets.index(alphabet),
               len(alphabets)-alphabets.index(alphabet))


# ì¢Œìš° ì¡°ì´ìŠ¤í‹± íšŸìˆ˜ ì„¸ê¸°
def calculate_horizontal(cur_idx, target_idx, n):
    return min(abs(target_idx-cur_idx), cur_idx+n-target_idx)


# í˜„ì¬ idxì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ Aê°€ ì•„ë‹Œ, ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ íƒ€ê²Ÿ ì°¾ê¸°
def find_next(cur_idx, name, ck, n):
    target_idx = 0
    min_step = len(name)
    done = True
    # ë§¤ë²ˆ ëª¨ë“  Aê°€ ì•„ë‹ˆê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ì•ŒíŒŒë²³ì— ëŒ€í•´ ê±°ë¦¬ë¥¼ ê³„ì‚°í•œë‹¤
    for i in range(len(name)):
        if ck[i] == False and name[i] != "A":
            done = False
            calculated_step = calculate_horizontal(cur_idx, i, n)
            if calculated_step < min_step:
                target_idx = i
                min_step = calculated_step
    if done:
        return [-1, -1]
    return [target_idx, min_step]


def solution(name):
    ck = [False for i in range(len(name))]
    ck[0] = True
    n = len(name)
    result = calculate_vertical(name[0])
    cur_idx = 0
    while True:
        target_idx, min_step = find_next(cur_idx, name, ck, n)
        if min_step == -1:
            break
        ck[target_idx] = True
        cur_idx = target_idx
        result += min_step + calculate_vertical(name[target_idx])
    return result
```

í•µì‹¬ì€ **find_next** í•¨ìˆ˜ì¸ë°, ì´ í•¨ìˆ˜ëŠ” idxì—ì„œ ì‹œì‘í•´ ë‚˜ë¨¸ì§€ ëª¨ë“  ì•ŒíŒŒë²³ë“¤ì— ëŒ€í•´

- Aê°€ ì•„ë‹ˆë©´ì„œ (AëŠ” ë°©ë¬¸í•  í•„ìš”ê°€ ì—†ë‹¤)
- ë°©ë¬¸í•˜ì§€ ì•Šì•˜ìœ¼ë©´ì„œ (ë°©ë¬¸ ì—¬ë¶€ëŠ” ck ë°°ì—´ë¡œ ê´€ë¦¬í•œë‹¤)
- ê°€ì¥ ê±°ë¦¬ê°€ ì§§ì€ (ì—­ë°©í–¥, ì •ë°©í–¥ ê±°ë¦¬ë¥¼ ê³„ì‚°í•´ ê·¸ ì¤‘ ìµœì†Œê°’ì„ ê±°ë¦¬ë¡œ í•œë‹¤) - `calculate_horizontal` í•¨ìˆ˜ê°€ ë‹´ë‹¹í•œë‹¤.

ì•ŒíŒŒë²³ê³¼ ê·¸ ê±°ë¦¬ë¥¼ ì°¾ê³ , ì´ë¥¼ ë¦¬í„´í•œë‹¤.



### ê·¸ëŸ°ë°...

ì´ ë¬¸ì œê°€ ì¡°ê¸ˆ ì˜ëª»ë˜ì—ˆë‹¤ê³  ëŠë¼ëŠ” ê²ƒì´, ë¬¸ì œ ë¶„ë¥˜ëŠ” ê·¸ë¦¬ë””ì¸ë° ë¬¸ì œì—ì„œëŠ” **ìµœì†Œê°’**ì„ ì°¾ìœ¼ë¼ê³  í•˜ê³  ìˆë‹¤.

ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì€ í˜„ì¬ì˜ ìµœì ì„ ì„ íƒí•˜ê¸° ë•Œë¬¸ì— ìµœì í•´ê°€ ì•„ë‹ ìˆ˜ë„ ìˆë‹¤. ë‚´ ì½”ë“œëŠ” ê·¸ë¦¬ë””í•˜ê²Œ í˜„ì¬ ìƒíƒœì—ì„œì˜ ìµœì†Œê°’ì„ ê³„ì‚°í•´ ë‹¤ìŒ ì´ë™ ìœ„ì¹˜ë¥¼ ê²°ì •í•˜ëŠ”ë°, ì´ ê²°ì •ì€ ì „ì²´ì ìœ¼ë¡œ ë³´ì•˜ì„ ë•Œ ìµœì í•´ê°€ ì•„ë‹ ìˆ˜ë„ ìˆë‹¤.



ë‹¨ì ì¸ ì˜ˆì‹œë¡œ ë‚´ ì½”ë“œëŠ” ACë¥¼ ë°›ì§€ë§Œ, ì•„ë˜ì™€ ê°™ì€ ë°˜ë¡€ê°€ ì¡´ì¬í•œë‹¤.

`ABABAAAAAAABA` : ìµœì†Œ 10, ë‚´ ì½”ë“œ 11

ì´ ì½”ë“œëŠ” ì²˜ìŒì— ì—­ë°©í–¥ìœ¼ë¡œ ì§„í–‰í•´ -2ì˜ Bë¥¼ ë°©ë¬¸í•œ ë’¤, ë‹¤ì‹œ ì •ë°©í–¥ìœ¼ë¡œ ì§„í–‰í•´ì•¼ ìµœì†Œê°’ì¸ 10ì´ ë‚˜ì˜¨ë‹¤. (0 -1 -2 -1 0 1 2 3 ìˆœìœ¼ë¡œ ì§„í–‰)

í•˜ì§€ë§Œ ë‚´ ì½”ë“œëŠ” 0ì—ì„œ ê·¸ë¦¬ë””í•˜ê²Œ ë‹¤ìŒ íƒ€ê²Ÿì„ ì •í•˜ê¸° ë•Œë¬¸ì—, ì—­ë°©í–¥ ê±°ë¦¬ 2ì¸ Bê°€ ì•„ë‹Œ, ì •ë°©í–¥ ê±°ë¦¬ 1ì¸ Bë¥¼ ì„ íƒí•´ ì§„í–‰í•œë‹¤. ë”°ë¼ì„œ 11ì´ ë‚˜ì˜¨ë‹¤.

`CANAAAAANAN` : ìµœì†Œê°’ 48, ë‚´ ì½”ë“œ 50

ì´ ë¬¸ì œë„ ë§ˆì°¬ê°€ì§€ë¡œ, ë‚´ ì½”ë“œëŠ” ì²˜ìŒë¶€í„° ì—­ë°©í–¥ìœ¼ë¡œ ì§„í–‰í•´ë²„ë¦¬ê¸° ë•Œë¬¸ì— ìµœì†Œê°’ì´ ë‚˜ì˜¤ì§€ ì•ŠëŠ”ë‹¤.



ë¬´íŠ¼ ê·¸ë¦¬ë””í•˜ê²Œ "í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ Aê°€ ì•„ë‹Œ, ë°©ë¬¸í•˜ì§€ ì•Šì€ ì•ŒíŒŒë²³" ì„ ì„ íƒí•´ë‚˜ê°€ë©´ ACë¥¼ ë°›ì„ ìˆ˜ëŠ” ìˆê¸´ í•˜ì§€ë§Œ, ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ” **"ì¡°ì´ìŠ¤í‹± ì¡°ì‘ íšŸìˆ˜ì˜ ìµœì†Ÿê°’"** ì€ ì•„ë‹ˆë‹¤. ë¬¸ì œê°€ ì¢€ í—ˆì ì´ ìˆëŠ” ê²ƒ ê°™ë‹¤. ğŸ˜ 



## êµ¬ëª…ë³´íŠ¸

DP + ê·¸ë¦¬ë””ë¡œ í’€ì—ˆë‹¤.

ê° ì‚¬ëŒì˜ ëª¸ë¬´ê²Œê°€ 40kg ì´ìƒ 240kg ì´í•˜ë¡œ ë¹„êµì  ì‘ì€ ë²”ìœ„ì˜€ê¸°ì—, ë¬´ê²Œë§ˆë‹¤ ì‚¬ëŒ ìˆ˜ë¥¼ ì €ì¥í•´ë‘ê³  people ë°°ì—´ì„ í•œë²ˆ ì •ë ¬í•œ ë’¤ ë¬´ê±°ìš´ ì‚¬ëŒë¶€í„° í•©ìŠ¹ ê°€ëŠ¥í•œ ì‚¬ëŒì´ ìˆë‚˜ ì²´í¬í–ˆë‹¤.

```python
def solution(people, limit):
    weight_count = [0 for i in range(241)]
    answer = 0
    n = len(people)
    done = 0
    people.sort()
    for w in people:
        weight_count[w] += 1
    while done < n:
        done += 1
        answer += 1
        cur_weight = people.pop()
        for i in range(limit-cur_weight, 39, -1):
            if weight_count[i] > 0:
                weight_count[i] -= 1
                done += 1
                break
    return answer
```

ì© ì¢‹ì€ í’€ì´ëŠ” ì•„ë‹Œ ê²ƒ ê°™ë‹¤.

#### ëª¨ë²” ë‹µì•ˆ

ì•„ë˜ íˆ¬ í¬ì¸í„° (?) í’€ì´ê°€ ì •ì„ì¸ë“¯.

ìƒê°í•´ë³´ë©´ í•œë²ˆ ì •ë ¬í•´ë‘ë©´ ìµœê³ ë¡œ í° ê°’ê³¼ ìµœê³ ë¡œ ì‘ì€ ê°’ì„ ë§¤ì¹­í•´ì£¼ëŠ”ê²Œ ìµœì  ê°’ì¸ ê²ƒì´ ë‹¹ì—°í•˜ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ìµœëŒ€ê°’, ìµœì†Œê°’ í¬ì¸í„°ë¥¼ ì •í•´ë‘ê³  í•˜ë‚˜ì”© ì¤„ì—¬ê°€ë©´ì„œ ë§¤ì¹­í•´ì£¼ê¸°!

```python
def solution(people, limit) :
    answer = 0
    people.sort()

    a = 0
    b = len(people) - 1
    while a < b :
        if people[b] + people[a] <= limit :
            a += 1
            answer += 1
        b -= 1
    return len(people) - answer
```



## ë‹¨ì†ì¹´ë©”ë¼

ì™œ ê·¸ë¦¬ë””ëŠ” í•­ìƒ í’€ ë•Œë§ˆë‹¤ í™•ì‹ ì´ ì•ˆë“¤ê¹Œ? ğŸ™ƒ

ì§„ì… ì§€ì  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•œ ë’¤, ê²¹ì¹˜ëŠ” ê²ƒì—  í•„ìš”í•œ end ì§€ì ì„ ì—…ë°ì´íŠ¸ í•´ê°€ë©´ì„œ end ì§€ì ì— í¬í•¨ë˜ì§€ ì•Šì„ ì‹œ í•„ìš”í•œ ê°ì‹œì¹´ë©”ë¼ +1 ì„ í•´ì£¼ëŠ” ë¡œì§ìœ¼ë¡œ í’€ì—ˆë‹¤.

```python
def solution(routes):
    answer = 0
    routes.sort()
    curr_end = -30001
    for car in routes:
        start, end = car
        if start <= curr_end:
            if curr_end > end:
                curr_end = end
            continue
        answer += 1

        curr_end = end
    return answer
```

#### ëª¨ë²” ë‹µì•ˆ

ë‚˜ëŠ” ì§„ì… ì§€ì ìœ¼ë¡œ ì •ë ¬í–ˆëŠ”ë°, **ëë‚˜ëŠ” ì§€ì  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬**í•˜ë©´ ë” í¸í•˜ë‹¤.

```python
def solution(routes):
    routes = sorted(routes, key=lambda x: x[1])
    last_camera = -30000

    answer = 0

    for route in routes:
      	# ì €ì¥ëœ ëë‚˜ëŠ” ì§€ì  < ë‹¤ìŒ ì• ì˜ ì‹œì‘ ì§€ì ì´ë©´ ìƒˆë¡œìš´ ê°ì‹œì¹´ë©”ë¼ë¥¼ ì„¤ì¹˜
        if last_camera < route[0]:
            answer += 1
            # ì €ì¥ëœ ëë‚˜ëŠ” ì§€ì ì„ ìƒˆë¡œìš´ ì• ì˜ ëë‚˜ëŠ” ì§€ì ìœ¼ë¡œ ë³€ê²½
            last_camera = route[1]

    return answer
```

í˜„ì¬ ì• ì˜ ëë‚˜ëŠ” ì§€ì ì„ ì €ì¥í•´ë‘ê³ ,  ì €ì¥ëœ ëë‚˜ëŠ” ì§€ì  >= ë‹¤ìŒ ì• ì˜ ì‹œì‘ ì§€ì  ì¸ì§€ íŒŒì•…ì„ í•˜ë©´ ë˜ë‹ˆê¹Œ!



## ì„¬ ì—°ê²°í•˜ê¸°

nê°œì˜ ì„¬ ì‚¬ì´ì— ë‹¤ë¦¬ë¥¼ ê±´ì„¤í•˜ëŠ” ë¹„ìš©ì´ ì£¼ì–´ì§ˆ ë•Œ, ìµœì†Œì˜ ë¹„ìš©ìœ¼ë¡œ ëª¨ë“  ì„¬ì´ ì„œë¡œ í†µí–‰ ê°€ëŠ¥í•˜ë„ë¡ ë§Œë“¤ ë•Œ í•„ìš”í•œ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•´ë¼ = MSTë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œ!

ì´ ë¬¸ì œ ë•ë¶„ì— ì˜¤ëœë§Œì— **í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜**ì„ ë³µìŠµí–ˆë‹¤. [ì°¸ê³  ë§í¬](https://www.fun-coding.org/Chapter20-prim-live.html)

```python
import heapq

# í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©


def solution(n, costs):
    answer = 0
    costs = [[cost[2], cost[0], cost[1]] for cost in costs]
    mst = []
    adj_edges = [[] for i in range(n)]
    for cost, n1, n2 in costs:
        adj_edges[n1].append([cost, n1, n2])
        adj_edges[n2].append([cost, n2, n1])
    connected_nodes = set([costs[0][1]])
    candidate_edges = adj_edges[costs[0][1]]
    heapq.heapify(candidate_edges)

    while candidate_edges:
        cost, n1, n2 = heapq.heappop(candidate_edges)
        if n2 not in connected_nodes:
            connected_nodes.add(n2)
            answer += cost
            for edge in adj_edges[n2]:
                if edge[2] not in connected_nodes:
                    heapq.heappush(candidate_edges, edge)
    return answer


print(solution(4, [[0, 1, 1], [0, 2, 2], [1, 2, 5], [1, 3, 1], [2, 3, 8]]))
```

ì´ ë¬¸ì œëŠ” ì˜¤íˆë ¤ í¬ë£¨ìŠ¤ì¹¼ë¡œ í’€ë©´ ë” ë³µì¡í•œ ê²ƒ ê°™ë‹¤. ë‘ ì•Œê³ ë¦¬ì¦˜ì˜ ì¥ë‹¨ì ì„ ì•Œê³  ê·¸ë•Œ ê·¸ë•Œ ë§ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•´ì•¼ í•  ë“¯.

### í”„ë¦¼ vs í¬ë£¨ìŠ¤ì¹¼

í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜, í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ëª¨ë‘ ê·¸ë¦¬ë””ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ” MST ì•Œê³ ë¦¬ì¦˜.

í”„ë¦¼ì€ ì„ì˜ì˜ ì •ì ì—ì„œ ì‹œì‘í•´ì„œ heapqì¸ candidate_list ë¥¼ ì—…ë°ì´íŠ¸ í•´ê°€ë©° MSTë¥¼ ì™„ì„±í•´ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ê³ , í¬ë£¨ìŠ¤ì¹¼ì€ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ë¶€í„° ì‹¸ì´í´ì´ ìƒê¸°ì§€ ì•Šê²Œ ì„ íƒí•˜ë©´ì„œ (union-find) MSTë¥¼ ì™„ì„±í•´ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.



## ì €ìš¸

ì•„ì´ë””ì–´ë¥¼ ìƒê°í•˜ëŠ”ë°ì—ëŠ” ì‹œê°„ì´ ì¢€ ê±¸ë ¸ì§€ë§Œ, ë– ì˜¤ë¥´ê³  ë‚œ ë’¤ì—” ê¸ˆë°© í’€ì—ˆë‹¤.

ë¬´ê²Œê°€ ì‘ì€ ìˆœìœ¼ë¡œ ì¶”ë¥¼ ì •ë ¬í•˜ê³ , ì¶”ë¥¼ ë”í•´ê°€ë©´ì„œ (cumm_sum) ì§€ê¸ˆê¹Œì§€ì˜ ì—°ì†ëœ ì¶”ë“¤ê³¼ í˜„ì¬ì˜ ì¶”ì˜ ì¡°í•©ìœ¼ë¡œ ë‹¤ìŒ ë‚˜ì™€ì•¼ í•  ê°’ì„ êµ¬í•  ìˆ˜ ì—†ë‹¤ë©´ return í•˜ë„ë¡.

```python
def solution(weight):
    weight.sort()
    cumm_sum = 0
    for w in weight:
        cumm_sum += w
        if cumm_sum-2*w+1 < 0:
            return cumm_sum-w+1
    return cumm_sum+1


print(solution([1, 1, 1, 1, 1]))
```

#### ëª¨ë²” ë‹µì•ˆ

ì•„ë˜ì²˜ëŸ¼ ì½”ë“œë¥¼ ì‘ì„±í•˜ë©´, ansê°€ ê³§ ë‹¤ìŒ ë§Œë“¤ì–´ì•¼ í•  ìµœì†Œê°’ì´ë‹¤.

ë‹¤ìŒ ì˜¤ëŠ” ì¶”ëŠ” (1...ans-1) ì˜ ì¶”ë“¤ê³¼ ìê¸°ìì‹  (e) ì˜ ë¬´ê²Œë¥¼ ê°€ì§€ê³  ansë¥¼ ë§Œë“¤ì–´ì•¼ í•œë‹¤. ë”°ë¼ì„œ eê°€ ans ë³´ë‹¤ í¬ë‹¤ë©´ ì ˆëŒ€ ansë¥¼ ë§Œë“¤ ìˆ˜ ì—†ê¸°ì— ansê°€ ë§Œë“¤ ìˆ˜ ì—†ëŠ” ìµœì†Œê°’ì´ ëœë‹¤.

```python
def solution(weight):
    weight.sort()
    ans = 1
    for e in weight:
        if ans < e:
            break
        ans += e

    return ans
```

ì‹ ë°•í•˜êµ°....