## ë¼ë©´ê³µì¥

`ì²˜ìŒ í’€ì´`

```python
import heapq


def solution(stock, dates, supplies, k):
    curr_date = 0
    curr_stock = stock
    curr_idx = 0
    answer = 0
    while curr_date + curr_stock < k:
        for i in range(0, len(dates)):
            if dates[i] > curr_date + curr_stock:
                curr_idx = i-1
                break
            else:
                curr_idx = i
        candidate_queue = [[-(supplies[i]+dates[i]), i]
                           for i in range(0, curr_idx+1)]
        heapq.heapify(candidate_queue)
        curr_idx = heapq.heappop(candidate_queue)[1]
        answer += 1
        curr_stock += supplies[curr_idx] - (dates[curr_idx] - curr_date)
        curr_date = dates[curr_idx]
        if curr_idx+1 != len(dates):
            dates = dates[curr_idx+1:]
            supplies = supplies[curr_idx+1:]
    return answer
```

<img src="á„’á…µá†¸.assets/á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2020-07-01 á„‹á…©á„’á…® 12.50.19.png" alt="á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2020-07-01 á„‹á…©á„’á…® 12.50.19" style="zoom: 33%;" />

ë­ê°€ í‹€ë¦°ì§€ ëª¨ë¥´ê² ì–´ì„œ [í•´ì„¤](https://minnnne.tistory.com/15) ë´¤ë‹¤. ğŸ˜¨ ì–´ë ¤ì›Œ...

`ë‹¤ì‹œ í‘¼ í’€ì´`

```python
import heapq


def solution(stock, dates, supplies, k):
    answer = 0
    queue = []
    supply_idx = 0
    while stock < k:
        for i in range(supply_idx, len(supplies)):
            if dates[i] <= stock:
                heapq.heappush(queue, -supplies[i])
                supply_idx = i+1
            else:
                break
        stock += heapq.heappop(queue)*(-1)
        answer += 1
    return answer
```

1. **í˜„ì¬ ì¬ê³ ë¥¼ ë‹¤ ì¶”ì í•  í•„ìš”ê°€ ì—†ë‹¤**. ë³µì¡ì„±ì€ í˜„ì¬ ë‚ ì§œì™€ ì¬ê³ ë¥¼ ì¶”ì í•˜ëŠ” ê²ƒì—ì„œ ë‚˜ì˜¨ë‹¤. ê¸°ì¡´ stock ì— ì¬ê³ ë¥¼ ëˆ„ì í•´ì„œ ë”í•œ ê°’ì´ k ì´ìƒì´ ë˜ê¸°ë§Œ í•˜ë©´ ëœë‹¤.
2. ì•„ì´ë””ì–´ëŠ” ê³µê¸‰ ì¼ìë¥¼ ë§Œë‚  ë•Œë§ˆë‹¤ ë°›ëŠ”ê²Œ ì•„ë‹ˆë¼, stockì´ 0ì´ ë˜ì—ˆì„ ë•Œë§ˆë‹¤ í˜„ì¬ queue ì¤‘ (ê³µê¸‰ ë°›ì„ ìˆ˜ ìˆëŠ” ì¼ì) ê°€ì¥ í° ì¬ê³ ë¥¼ ê³µê¸‰ë°›ëŠ” ê²ƒ

```python
while stock < k:
  # ì§ì „ì— ê³µê¸‰ ë°›ì€ ì¼ì ì´í›„ë¶€í„°, ë§ˆì§€ë§‰ ê³µê¸‰ ì¼ìê¹Œì§€ loop
  for i in range(supply_idx, len(supplies)):
    # í˜„ì¬ stockì€ ë‚´ê°€ ë‹¤ìŒì— ê³µê¸‰ë°›ì•„ì•¼ í•  ë§ˆì§€ë…¸ì„  ì¼ìë¥¼ ì˜ë¯¸í•œë‹¤. ê·¸ ì¼ìë³´ë‹¤ ê°™ê±°ë‚˜ ì‘ìœ¼ë©´ queueì— í›„ë³´ë¡œ ë“¤ì–´ê°„ë‹¤.
    if dates[i] <= stock:
      heapq.heappush(queue, -supplies[i])
      # ë‹¤ìŒ íƒìƒ‰ ì‹œì—ëŠ” ë§ˆì§€ë§‰ìœ¼ë¡œ ë“¤ì–´ê°„ ê³µê¸‰ì¼ ì´í›„ë¶€í„° ê³ ë ¤í•˜ë©´ ëœë‹¤.
      supply_idx = i+1
    else:
      # ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ë˜ì–´ ìˆìœ¼ë¯€ë¡œ í•œë²ˆ ë§ˆì§€ë…¸ì„  ì¼ì ì´í›„ì˜ ê³µê¸‰ì¼ì„ ë§Œë‚˜ë©´ loop íƒˆì¶œ
      break
    # ê°€ëŠ¥í•œ ê³µê¸‰ì¼ ì¤‘ ê°€ì¥ í° supply ê°’ì„ ë”í•œë‹¤
    stock += heapq.heappop(queue)*(-1)
    answer += 1
```

**"stock ì„ ëˆ„ì í•´ê°ˆ ë•Œ, ê·¸ ëˆ„ì ëœ stockì€ ë‚´ê°€ ë‹¤ìŒì— ê³µê¸‰ë°›ì•„ì•¼ í•  ë§ˆì§€ë…¸ì„  ì¼ìë‹¤"** ë¼ëŠ” ì•„ì´ë””ì–´ê°€ ê°€ì¥ ì¤‘ìš”í–ˆë˜ ê²ƒ ê°™ë‹¤.



ì•„ì§ ì•Œê³ ë¦¬ì¦˜ì„ í’€ ë•Œ ë¶ˆí•„ìš”í•˜ê²Œ ë³µì¡ë„ë¥¼ ë†’íˆëŠ” ê²½í–¥ì´ ìˆëŠ” ê²ƒ ê°™ë‹¤.

ë¬¸ì œë§Œ ë³´ë©´ ë‚ ì§œë¥¼ ì¶”ì í•´ì•¼ í•  ê²ƒ ê°™ë”ë¼ë„, ê¼­ ë‚ ì§œë¥¼ ì¶”ì í•´ì•¼ í•˜ë‚˜? ì¶”ì í•˜ì§€ ì•Šê³ ë„ ê°’ì„ êµ¬í•  ìˆœ ì—†ë‚˜? ì´ëŸ° ìƒê°ì„ ê³„ì† í•´ë³´ì.



## ë””ìŠ¤í¬ ì»¨íŠ¸ë¡¤ëŸ¬
`í’€ì´`

```python
import heapq


def solution(jobs):
    heapq.heapify(jobs)
    candidate_queue = []
    curr_time = jobs[0][0]
    answer = []
    while candidate_queue or jobs:
        if candidate_queue:
            target = heapq.heappop(candidate_queue)
            curr_time += target[0]
            answer.append(curr_time-target[1])
            while True:
                if jobs and jobs[0][0] <= curr_time:
                    heapq.heappush(candidate_queue, heapq.heappop(jobs)[::-1])
                else:
                    break
        else:
            target = heapq.heappop(jobs)
            curr_time = target[0]+target[1]
            answer.append(target[1])
            while True:
                if jobs and jobs[0][0] <= curr_time:
                    heapq.heappush(candidate_queue, heapq.heappop(jobs)[::-1])
                else:
                    break
    return sum(answer)//len(answer)
```

ë¼ë©´ê³µì¥ ë¬¸ì œë¥¼ í’€ê³  ë‚œ ë’¤ì— í’€ì–´ì„œ ê·¸ë‚˜ë§ˆ ì¡°ê¸ˆ í‰ì´í–ˆëŠ”ë°,  ëª‡ê°€ì§€ ì‹¤ìˆ˜ë¥¼ í–ˆë‹¤.

ê¸°ë³¸ì ì¸ ë¡œì§ì€ jobs queueì™€ candidate queue ì´ë ‡ê²Œ 2ê°œì˜ heap queueë¥¼ ë‘ê³ , candidate queueê°€ ë¹„ì—ˆìœ¼ë©´ jobs queueì—ì„œ ìš”ì²­ ì‹œê°„ì´ ê°€ì¥ ë¹ ë¥¸ ì• ë¥¼ ìˆ˜í–‰í•œ ë’¤, ê±”ê°€ ëë‚  ë•Œ ê¹Œì§€ ë˜ ìƒˆë¡­ê²Œ ìš”ì²­ì´ ë“¤ì–´ì˜¨ ì• ë¥¼ jobs queueì—ì„œ íƒìƒ‰í•´ì„œ candidate queueì— ì „ë¶€ ë„£ëŠ”ë‹¤.

candidate queueê°€ ë¹„ì§€ ì•Šì•˜ë‹¤ë©´ candidate queueì—ì„œ ìˆ˜í–‰ ì‹œê°„ì´ ê°€ì¥ ì§§ì€ ì• ë¥¼ ìˆ˜í–‰í•œ ë’¤,  ê±”ê°€ ëë‚  ë•Œ ê¹Œì§€ ë˜ ìƒˆë¡­ê²Œ ìš”ì²­ì´ ë“¤ì–´ì˜¨ ì• ë¥¼ jobs queueì—ì„œ íƒìƒ‰í•´ì„œ  candidate queueì— ì „ë¶€ ë„£ëŠ”ë‹¤.

Jobs queueì—ì„œëŠ” ë¹¼ëŠ” ê¸°ì¤€ì´ ìš”ì²­ì‹œê°„ (ë¹ ë¥¸ ìˆœ) ì´ì–´ì•¼ í•˜ê³ , candidate queueì—ì„œëŠ” ë¹¼ëŠ” ê¸°ì¤€ì´ ìˆ˜í–‰ì‹œê°„ (ì§§ì€ ìˆœ) ì´ì–´ì•¼ í•˜ê¸°ì— heapqì— ë„£ì„ ë•Œ ì„œë¡œ ë‹¤ë¥¸ í˜•ì‹ìœ¼ë¡œ ë„£ì–´ì¤˜ì•¼ í•œë‹¤.

[ì‹¤ìˆ˜í•œ ë¶€ë¶„]

- ë§¨ ì²˜ìŒ ì‹œì‘ timeì„ 0ìœ¼ë¡œ ì„¤ì •í•˜ë©´ ì•ˆëœë‹¤. ë§¨ ì²˜ìŒ ìš”ì²­ë˜ëŠ” ì‘ì—…ì˜ ìš”ì²­ì‹œê°„ì´ 0ì´ë¼ëŠ” ë³´ì¥ì´ ì—†ë‹¤.
- candidate queueê°€ ì—†ë‹¤ë©´, curr_timeì´ ì´ì „ curr_timeì— í˜„ì¬ì‘ì—…ì‹œê°„ì„ ë”í•œ ê²ƒì´ ì•„ë‹Œ, í˜„ì¬ ì‘ì—… ì‹œê°„ì˜ ìš”ì²­ì‹œê°„ì´ ë˜ì–´ì•¼ í•œë‹¤. Candidate queueê°€ ë¹„ì—ˆë‹¤ëŠ” ë§ì€ í•˜ë“œë””ìŠ¤í¬ê°€ ì‘ì—…ì„ ìˆ˜í–‰í•˜ê³  ìˆì§€ ì•Šë‹¤ëŠ” ë§ì´ë¯€ë¡œ, ë‹¤ìŒ ì‘ì—…ì˜ ìš”ì²­ì‹œê°„ì´ í˜„ì¬ì‹œê°„ìœ¼ë¡œ ê³„ì‚°ë˜ì–´ì•¼ í•œë‹¤.

## ì´ì¤‘ìš°ì„ ìˆœìœ„í

ë­”ê°€ ì–´ê±°ì§€ë¡œ í’€ì—ˆë‹¤... ì´ë ‡ê²Œ í’€ë©´ ì•ˆë˜ëŠ” ë¬¸ì œ ê°™ì€ë°...ğŸ˜‘ í…Œì¼€ê°€ ëª‡ê°œ ì—†ì–´ì„œ í†µê³¼í•œ ê²ƒ ê°™ìŒ.

`í’€ì´`

```python
import heapq


def solution(operations):
    max_heap = []
    min_heap = []
    total_length = 0
    for operation in operations:
        oper_arr = operation.split(" ")
        value = int(oper_arr[1])
        if oper_arr[0] == "I":
            heapq.heappush(max_heap, -value)
            heapq.heappush(min_heap, value)
            total_length += 1
        else:
            if total_length < 1:
                continue
            if value == 1:
                heapq.heappop(max_heap)
                total_length -= 1
            else:
                heapq.heappop(min_heap)
                total_length -= 1
            if total_length == 0:
                max_heap = []
                min_heap = []
        print(operation, max_heap, min_heap)
    if total_length == 0:
        return [0, 0]
    else:
        return [-heapq.heappop(max_heap), heapq.heappop(min_heap)]
```

ì²˜ìŒì—” ê·¸ëƒ¥ ë‹¨ìˆœí•˜ê²Œ heap 2ê°œ ì“°ë©´ ë˜ê² ì§€! ë¼ê³  ìƒê°í–ˆëŠ”ë°, ê·¸ë ‡ê²Œ í’€ë©´ ë‘ heapê°„ì˜ ë™ê¸°í™”ê°€ ì•ˆë¼ì„œ í‹€ë¦°ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ì˜ ê²½ìš°

`print(solution(["I 4", "I 3", "I 2", "I 1", "D 1", "D 1", "D -1", "D -1", "I 5", "I 6"]))`

Dë¥¼ ë‹¤ ìˆ˜í–‰í•˜ê³  ë‚˜ë©´ ì „ì²´ ê°’ì´ 0ì´ ë˜ì–´ì•¼ í•˜ëŠ”ë°, minHeapì—ëŠ” ì´ë¯¸ ì‚­ì œëœ 4,3ì´ ë‚¨ì•„ìˆê³ , maxHeapì—ëŠ” ë§ˆì°¬ê°€ì§€ë¡œ ì´ë¯¸ ì‚­ì œëœ 1,2ê°€ ë‚¨ì•„ìˆê²Œ ëœë‹¤.

ë‚˜ëŠ” ì´ê±¸ ë°°ì—´ ê¸¸ì´ê°€ 0ì´ ë˜ì—ˆì„ ë•Œ ë‘ í™ì„ ë‹¤ ë¹„ì›Œì£¼ëŠ” ì‹ìœ¼ë¡œ ë™ê¸°í™”í•˜ëŠ” ê¼¼ìˆ˜ë¥¼ ë¶€ë ¤ì„œ acë¥¼ ë°›ê¸´ í–ˆëŠ”ë°... í ...

`ë‹¤ë¥¸ í’€ì´`

[ì°¸ê³  ë§í¬](https://programmers.co.kr/learn/courses/30/lessons/42628/solution_groups?language=python3)

```python
def solution(operations):
    heap = []

    for operation in operations:
        operator, operand = operation.split(' ')
        operand = int(operand)

        if operator == 'I':
            heapq.heappush(heap, operand)
        elif heap:
            if operand < 0:
                heapq.heappop(heap)
            else:
                heap.remove(max(heap))

    if not heap:
        return [0, 0]

    return [max(heap), heap[0]]
```

ìŒ.. ê·¸ëƒ¥ ìµœì†Œ í™ 1ê°œë§Œ ì“°ì‹œê³  maxë¥¼ ì¨ë„ ì•ˆí„°ì§€ë‚˜ë¶€ë‹¤. operations ìµœëŒ€ ê¸¸ì´ê°€ ë°±ë§Œì´ë¼ì„œ ì‹œê°„ë³µì¡ë„ ì•ˆí„°ì§€ëŠ” ë“¯. ë ìš”ì˜¹



## ìˆ«ìì˜ í‘œí˜„

ì‹œê°„ì´ˆê³¼ ì•ˆë‚˜ë„¤...?

[ì²˜ìŒ í’€ì´]

```python
def solution(n):
    answer = 1
    for i in range(1, (n//2)+1):
        sum_value = i
        j = i
        while sum_value <= n:
            j += 1
            sum_value += j
            if sum_value == n:
                answer += 1
                break
    return answer
```

