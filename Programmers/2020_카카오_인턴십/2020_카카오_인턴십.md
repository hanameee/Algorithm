# 2020 ì¹´ì¹´ì˜¤ ì¸í„´ì‹­ ì½”ë”©í…ŒìŠ¤íŠ¸
## 1. í‚¤íŒ¨ë“œ ëˆ„ë¥´ê¸°

ê°„ë‹¨í•œ ì¡°ê±´ë¬¸ ë¬¸ì œì§€ë§Œ, ì‹¤ìˆ˜í•˜ê¸° ì‰¬ìš´ ë¬¸ì œ. ì‹œí—˜ ë³¼ ë•Œë„ ìœ„ì¹˜ë¥¼ height (row) ë§Œ ì €ì¥í•´ë‘ëŠ” ì‹¤ìˆ˜ë¥¼ í–ˆë˜ ê²ƒ ê°™ì€ë°, ë‹¤ì‹œ í’€ì–´ë³¼ ë•Œë„ ë˜‘ê°™ì€ ì‹¤ìˆ˜ë¥¼ í–ˆë‹¤. `2,5,8,0` ì„ ëˆŒë €ì„ ë•Œ ì™¼ì†ì´ ê°€ê¹Œìš´ì§€, ì˜¤ë¥¸ì†ì´ ê°€ê¹Œìš´ì§€ë¥¼ í™•ì¸í•˜ë ¤ë©´ **rowì™€ column ìœ„ì¹˜ë¥¼ ë‘˜ ë‹¤ ì €ì¥**í•´ë‘ì–´ì•¼ í•œë‹¤.

ì°¸ê³ ë¡œ rowëŠ” `(num-1)//3` ê³¼ ê°’ì´ ê°™ê³ , columnì€ `(num-1)%3` ê³¼ ê°’ì´ ê°™ë‹¤ëŠ” ê·œì¹™ì´ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ rowëŠ” 1,2,3ì´ 0ì´ê³ , columnì€ 1,4,7ì´ 0ì´ê¸° ë•Œë¬¸ì—. ê° ìˆ«ì ë³„ í–‰/ì—´ ìœ„ì¹˜ë¥¼ í•˜ë“œì½”ë”©í•´ë„ ë˜ì§€ë§Œ, ê·œì¹™ì„ ì‚¬ìš©í•˜ë©´ ì¡°ê¸ˆ ë” ê°„ê²°í•˜ê²Œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.

ì²˜ìŒ ì†ê°€ë½ì´ ìœ„ì¹˜í•˜ëŠ” ê³³ì€ ë”°ë¡œ ì´ˆê¹ƒê°’ì„ ì„¤ì •í•´ì£¼ê³ , ìœ„ì¹˜ë¥¼ ê³„ì‚°í•´ì£¼ëŠ” í•¨ìˆ˜ë¥¼ ë”°ë¡œ ë¹¼ì„œ ëˆ„ë¥¸ ìˆ«ìê°€ 0ì¼ë•Œë§Œ ì˜ˆì™¸ì ìœ¼ë¡œ ìœ„ì¹˜ë¥¼ ë¦¬í„´í•´ì¤¬ë‹¤.

```python
# ìˆ«ìë¥¼ ë°›ì•„ ìœ„ì¹˜(í–‰,ì—´)ë¥¼ ê³„ì‚°í•´ì£¼ëŠ” í•¨ìˆ˜
def get_target_position(target):
    if target == 0:
        return [3, 1]
    else:
        return [(target-1)//3, (target-1) % 3]


def solution(numbers, hand):
  	# ì´ˆê¹ƒê°’ ì„¤ì •
    left_position = [3, 0]
    right_position = [3, 2]
    answer = ''
    for num in numbers:
        if num in [1, 4, 7]:
            answer += "L"
            left_position = get_target_position(num)
        elif num in [3, 6, 9]:
            answer += "R"
            right_position = get_target_position(num)
        else:
            target_position = get_target_position(num)
            # diff ë¥¼ ë¹„êµí•œë‹¤
            left_diff = abs(
                left_position[0]-target_position[0]) + abs(left_position[1]-target_position[1])
            right_diff = abs(
                right_position[0]-target_position[0]) + abs(right_position[1]-target_position[1])
            if left_diff < right_diff:
                answer += "L"
                left_position = target_position
            elif left_diff > right_diff:
                answer += "R"
                right_position = target_position
            # ì–‘ ì†ì˜ ê±°ë¦¬ê°€ ê°™ì„ ê²½ìš° handë¥¼ í™•ì¸í•œë‹¤
            else:
                if hand == "left":
                    answer += "L"
                    left_position = target_position
                else:
                    answer += "R"
                    right_position = target_position
    return answer


print(solution([7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2], "left"))
```



## 2. ìˆ˜ì‹ ìµœëŒ€í™”

ìŠ¤íƒ ì‚¬ìš©í•˜ëŠ” ë¬¸ì œ. expressionì„ ëŒë©´ì„œ ìˆ«ìì™€ ì—°ì‚°ìë¥¼ ê°ê° ë¶„ë¦¬í•´ì„œ ìŠ¤íƒì— ë„£ì–´ì£¼ê³ , ìŠ¤íƒì„ ëŒë©´ì„œ ì—°ì‚°ì ìš°ì„ ìˆœìœ„ë³„ë¡œ ì—°ì‚°í•˜ë©´ ëœë‹¤.

ì£¼ì˜í•´ì•¼í•  í¬ì¸íŠ¸ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

- str, int ìë£Œí˜• ì£¼ì˜í•˜ê¸°
- ì—°ì‚°í•œ ê²°ê³¼ë¥¼ ì–´ë–»ê²Œ stackì— ì €ì¥í•  ì§€
- ì‚¬ìš©í•œ ìˆ«ìëŠ” ì–´ë–»ê²Œ ì²˜ë¦¬í• ì§€ (pop í• ì§€, ë‹¤ë¥¸ ë¬¸ìë¡œ ì¹˜í™˜í• ì§€)

expressionì˜ ê¸¸ì´ê°€ ìµœëŒ€ 100 ë°–ì— ì•ˆë˜ê³ , ìŒìˆ˜ ìˆ«ìëŠ” ë“¤ì–´ì˜¤ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì¡°ê±´ì´ ìˆì–´ì„œ í¬ê²Œ ì–´ë µì§„ ì•Šë‹¤. input sizeê°€ ì‘ì€ ë§Œí¼ popì„ ì‚¬ìš©í•´ë„ ë  ê²ƒ ê°™ê¸´ í•˜ì§€ë§Œ ë‚˜ëŠ” popì„ ì•ˆì“°ê³  í’€ì–´ë³´ì•˜ë‹¤. 

ì—°ì‚°ìì˜ ìš°ì„ ìˆœìœ„ëŒ€ë¡œ í•œ ê°œì˜ ì—°ì‚°ìë§ˆë‹¤ for ë¬¸ìœ¼ë¡œ ìŠ¤íƒì„ ì²˜ìŒë¶€í„° ëŒë©´ì„œ, í•´ë‹¹ ì—°ì‚°ìë¥¼ ë§Œë‚˜ë©´ evalì„ í†µí•´ í˜„ì¬ ì¸ë±ìŠ¤ ê¸°ì¤€ prev ê°’ê³¼ next ê°’ì„ ì°¾ì•„ ì—°ì‚°í•œë‹¤.

ì—°ì‚°ì— ì‚¬ìš©í•œ ê°’ì€ ë‹¤ë¥¸ ê°’ë“¤ê³¼ ê²¹ì¹˜ì§€ ì•ŠëŠ” ê¸°í˜¸ (`_`) ë¡œ ë³€ê²½í•˜ê³ , ë³„ë„ì˜ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ì„œ prev_idxì™€ next_idxë¥¼ ì°¾ì„ ë•ŒëŠ” `_` ê°€ ì•„ë‹Œ ìœ íš¨í•œ ê°’ì´ ìˆëŠ” ì¸ë±ìŠ¤ë¥¼ ë¦¬í„´í•˜ë„ë¡ í–ˆë‹¤.

popì„ í•˜ë©´ for ëŒ€ì‹  whileì„ ì‚¬ìš©í•´ì•¼ í•˜ê³ , ìœ íš¨í•œ prev, next indexë¥¼ ì°¾ì•„ë‚´ëŠ” ë³„ë„ì˜ ë¡œì§ì´ í•„ìš” ì—†ì–´ì§€ëŠ” ì°¨ì´ì ì´ ìˆì„ ê²ƒ ê°™ë‹¤.

```python
from itertools import permutations
from copy import deepcopy


def find_prev_idx(stk, idx):
    for i in range(idx-1, -1, -1):
        if stk[i] != "_":
            return i


def find_next_idx(stk, idx):
    for i in range(idx+1, len(stk)):
        if stk[i] != "_":
            return i


def solution(expression):
    used_operator = []
    # ì‚¬ìš©ëœ ì—°ì‚°ì ì°¾ê¸°
    for char in expression:
        if char in ["*", "-", "+"] and char not in used_operator:
            used_operator.append(char)
    # ëª¨ë“  ì—°ì‚°ì ì¡°í•© êµ¬í•˜ê¸°
    candidate_operation = permutations(used_operator)
    temp = ""
    stk = []
    # ìˆ«ìì™€ ì—°ì‚°ìë¡œ ë¶„ë¦¬í•´ì„œ ìŠ¤íƒì— ë„£ê¸°
    for char in expression:
        if char in used_operator:
            stk.append(temp)
            stk.append(char)
            temp = ""
        else:
            temp += char
    stk.append(temp)
    answer = 0
    for candidate in candidate_operation:
        copied_stk = deepcopy(stk)
        # ìš°ì„ ìˆœìœ„ ì—°ì‚°ìë³„ë¡œ ëŒë©´ì„œ ê³„ì‚°í•´ì£¼ê¸°
        for operation in candidate:
            result = 0
            for idx in range(len(copied_stk)):
                if copied_stk[idx] == operation:
                    # _ê°€ ì•„ë‹Œ ì „í›„ ì¸ë±ìŠ¤ ì°¾ê¸°
                    prev_idx = find_prev_idx(copied_stk, idx)
                    next_idx = find_next_idx(copied_stk, idx)
                    copied_stk[idx] = eval(
                        str(copied_stk[prev_idx])+copied_stk[idx]+str(copied_stk[next_idx]))
                    # ì—°ì‚° ê²°ê³¼ë¥¼ resultì— ì €ì¥í•´ ìµœì¢… ê°’ì´ ìë™ìœ¼ë¡œ result ë³€ìˆ˜ì— ì €ì¥ë˜ê²Œ í•¨
                    result = copied_stk[idx]
                    # ì‚¬ìš©í•œ ê°’ì€ _ ë¡œ ë³€ê²½
                    copied_stk[prev_idx] = "_"
                    copied_stk[next_idx] = "_"
        answer = max(answer, abs(result))
    return answer
```



## 3. ë³´ì„ ì‡¼í•‘

ì‹œí—˜ ë³¼ ë•Œ 2ì‹œê°„ ë°˜ì´ë¼ëŠ” ì‹œê°„ì´ ë‚¨ì•˜ìŒì—ë„ ëª» í’€ì—ˆë˜ ë¬¸ì œ. ì‹œí—˜ì´ ëë‚œ í›„ íˆ¬ í¬ì¸í„°ë¡œ í‘¸ëŠ” ë¬¸ì œë¼ëŠ” ì–˜ê¸°ë¥¼ ë“£ê³ , ì´ë²ˆì— ë‹¤ì‹œ í’€ì–´ë´¤ëŠ”ë°ë„ ê½¤ ì˜¤ëœ ì‹œê°„ì´ ê±¸ë ¸ë‹¤.

### ë‚´ê°€ í–ˆë˜ ì‹¤ìˆ˜

ë‚´ê°€ í–ˆë˜ ê°€ì¥ í° ì°©ê°ì€ **ìµœì†Œ êµ¬ê°„ì´ ë°˜ë“œì‹œ min, max ì¸ë±ìŠ¤ì—ì„œ ë‚˜ì˜¬ ê²ƒì´ë¼ëŠ” ì°©ê°**ì´ì—ˆë‹¤. ì—¬ê¸°ì„œì˜ min, max ì¸ë±ìŠ¤ë€ start_pointerì´ ë  ìˆ˜ ìˆëŠ” ê°€ì¥ max ê°’ê³¼ end_pointerì´ ë  ìˆ˜ ìˆëŠ” ê°€ì¥ min ê°’ì„ ë§í•œë‹¤.

ë‹¤ì‹œ ë§í•˜ìë©´, ë‚˜ëŠ” ê° ë³´ì„ì´ ë“±ì¥í•œ íšŸìˆ˜ë¥¼ ì„¸ë©´ì„œ, ë“±ì¥í•œ ë³´ì„ì˜ ì¢…ë¥˜ ìˆ˜ê°€ ë‹¬ë¼ì§€ëŠ” ì„ê³„ê°’ (end_idxë¥¼ ë idxë¡œ ê³ ì •ì‹œì¼œ ë‘ì—ˆì„ ë•Œ ê°€ëŠ¥í•œ start_idxì˜ ìµœëŒ€ê°’, ê·¸ ë•Œ ê°€ëŠ¥í•œ end_idxì˜ ìµœì†Œê°’) ì—ì„œ ìµœì†Œ êµ¬ê°„ì´ ë‚˜ì˜¬ ê²ƒì´ë¼ê³  ìƒê°í–ˆë‹¤. 

ì´ê±´ ì•„ì£¼ ì˜ëª»ëœ ìƒê°ì´ë‹¤. ë°˜ë¡€ë¥¼ ë“¤ì–´ë³´ìë©´

`1,2,4,1,1,3,1,1,2,3,4,4,3,4,4,2,1` ì´ë¼ëŠ” inputì´ ì£¼ì–´ì¡Œì„ë•Œ, max_start_idxëŠ” ì´í›„ë¡œ 1,2,3,4ê°€ ì ì–´ë„ í•œê°œ ë‚¨ì•„ìˆëŠ” [-5] ë¶€ë¶„ì´ê³ , min_end_idxëŠ” ì´ì „ì— 1,2,3,4ê°€ ì ì–´ë„ í•œê°œ ë‚¨ì•„ìˆëŠ” [5] ë¶€ë¶„ì´ë‹¤. ê·¸ëŸ°ë° ìµœì†Œ ê¸¸ì´ëŠ” [7:11] êµ¬ê°„ì¸ `1,2,3,4`  ì´ë‹¤.  ì´ êµ¬ê°„ì€ min, max ì¸ë±ìŠ¤ì™€ ì•„ë¬´ëŸ° ìƒê´€ì´ ì—†ë‹¤.

ìƒê°í•´ë³´ë©´, min, max ì¸ë±ìŠ¤ëŠ” ê°€ëŠ¥í•œ ë²”ìœ„ì˜ ë²”ìœ„ë§Œì„ ì•Œë ¤ì¤„ ë¿ (start_idxëŠ” ìµœëŒ€ ëª‡, end_idxëŠ” ìµœì†Œ ëª‡) ê·¸ ì•ˆì—ì„œì˜ lengthëŠ” ì§ì ‘ í•´ë³´ì§€ ì•Šìœ¼ë©´ ì•Œ ìˆ˜ê°€ ì—†ë‹¤.

### ac ë°›ì€ í’€ì´

ì´ ë¬¸ì œë¥¼ ë§ê²Œ í’€ê¸° ìœ„í•´ì„œëŠ” **ëª¨ë“  ì§€ì ì„ íƒìƒ‰**í•˜ë©° ìµœì ì˜ ê¸¸ì´ë¥¼ ì°¾ì•„ì•¼ í•œë‹¤. íˆ¬í¬ì¸í„°ë¥¼ ì´ìš©í•œë‹¤ë©´ O(n)ì˜ ì‹œê°„ë³µì¡ë„ë¡œ ë‹µì„ êµ¬í•  ìˆ˜ ìˆë‹¤.

```python
def solution(gems):
    gems_set = set(gems)
    gems_dict = {}
    min_length = float("inf")
    answer_arr = []
    start_idx = 0
    end_idx = 0
    # ê°€ì¥ ì²˜ìŒ ë‚˜ì˜¤ëŠ” ìœ íš¨í•œ êµ¬ê°„ ì°¾ê¸°
    for idx in range(len(gems)):
        if gems[idx] not in gems_dict:
            gems_dict[gems[idx]] = 1
            if len(gems_dict.keys()) == len(gems_set):
                end_idx = idx
                break
        else:
            gems_dict[gems[idx]] += 1
    while end_idx < len(gems):
        while gems_dict[gems[start_idx]] > 1:
            gems_dict[gems[start_idx]] -= 1
            start_idx += 1
        if min_length > end_idx - start_idx:
            answer_arr = [start_idx+1, end_idx+1]
            min_length = end_idx-start_idx
        end_idx += 1
        if end_idx < len(gems):
            gems_dict[gems[end_idx]] += 1
    return answer_arr
```

ë‚˜ëŠ” ì¼ë‹¨ ì²˜ìŒì— start_idxë¥¼ 0ìœ¼ë¡œ ë‘ê³ , end_idxë¥¼ ì¦ê°€ì‹œí‚¤ë©° ê°€ì¥ ì²˜ìŒ ë‚˜ì˜¤ëŠ” ìœ íš¨í•œ êµ¬ê°„ì„ ì°¾ì•˜ë‹¤.

ê·¸ ì´í›„ë¡œ, end_idxê°€ ëì— ë„ë‹¬í•  ë•Œê¹Œì§€ ì•„ë˜ ë¡œì§ì„ ë°˜ë³µí–ˆë‹¤.

- start_idxê°€ ê°€ë¥´í‚¤ëŠ” ë³´ì„ì˜ ê°¯ìˆ˜ê°€ 1ë³´ë‹¤ í¬ë‹¤ë©´, 1ì´ ë  ë•Œê¹Œì§€ start_idxë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤. (idxê°€ ì¦ê°€í•¨ì— ë”°ë¼ ë³´ì„ì˜ ê°¯ìˆ˜ëŠ” ì¤„ì–´ë“ ë‹¤)
- start_idxê°€ ê°€ë¥´í‚¤ëŠ” ë³´ì„ì˜ ê°¯ìˆ˜ê°€ 1ì´ ë˜ë©´, êµ¬ê°„ì˜ ê¸¸ì´ë¥¼ ì¬ê³  ìµœì†Œê¸¸ì´ë¼ë©´ ë‹µì„ ì—…ë°ì´íŠ¸í•œë‹¤.
- end_idxë¥¼ 1ì”© ì¦ê°€ì‹œí‚¤ê³  í•´ë‹¹í•˜ëŠ” ë³´ì„ì˜ ê°¯ìˆ˜ë¥¼ ì¦ê°€ì‹œí‚¨ ë’¤ ì²˜ìŒ ë¡œì§ë¶€í„° ë°˜ë³µí•œë‹¤.

ì¦‰, end_idxë¥¼ 1ì”© ì¦ê°€ì‹œí‚¤ë©´ì„œ **ìœ íš¨í•œ ìµœì†Œ êµ¬ê°„ ê¸¸ì´**ë¥¼ ê³„ì†í•´ì„œ ìœ ì§€í•˜ëŠ” ë°©ë²•ì´ë‹¤. ì²˜ìŒì— ìœ íš¨í•œ êµ¬ê°„ìœ¼ë¡œ ì‹œì‘í–ˆìœ¼ë¯€ë¡œ, start_idxê°€ ê°€ë¥´í‚¤ëŠ” ë³´ì„ì˜ êµ¬ê°„ ë‚´ ê°¯ìˆ˜ê°€ 1ì´ ë˜ë„ë¡ ìœ ì§€í•˜ê¸°ë§Œ í•œë‹¤ë©´ ê³„ì†í•´ì„œ ìœ íš¨í•œ êµ¬ê°„ (ëª¨ë“  ë³´ì„ì´ ì ì–´ë„ 1ê°œ í¬í•¨ëœ êµ¬ê°„) ì„ ë³´ì¥í•  ìˆ˜ ìˆë‹¤.

<img src="2020_á„á…¡á„á…¡á„‹á…©_á„‹á…µá†«á„á…¥á†«á„‰á…µá†¸.assets/image-20200707010127844.png" alt="image-20200707010127844" style="zoom:33%;" />

### ê³µì‹ í•´ì„¤ì„ ì°¸ê³ í•œ í’€ì´

[Kakao Tech ê³µì‹ í•´ì„¤](https://tech.kakao.com/2020/07/01/2020-internship-test/)

start_idxì™€ end_idx ëª¨ë‘ 0,0ì—ì„œ ì‹œì‘í•´, ì–‘ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ë²”ìœ„ ì•ˆì— í¬í•¨ëœ ë³´ì„ ì¢…ë¥˜ì˜ ê°œìˆ˜ë¥¼ ì„¼ë‹¤.

- ë²”ìœ„ ì•ˆì˜ ë³´ì„ ì¢…ë¥˜ê°€ ì „ì²´ ë³´ì„ ì¢…ë¥˜ì™€ ì¼ì¹˜í•˜ë©´, ìµœì†Œê°’ì¸ì§€ ì²´í¬í•˜ê³  ë‹µì„ ì—…ë°ì´íŠ¸í•œë‹¤. ê·¸ë¦¬ê³  start_idxë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤.
- ë²”ìœ„ ì•ˆì˜ ë³´ì„ ì¢…ë¥˜ê°€ ì „ì²´ ë³´ì„ ì¢…ë¥˜ë³´ë‹¤ ì‘ë‹¤ë©´, end_idxë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤. ê·¸ë¦¬ê³  ë°˜ë³µ.

ê³µì‹ í•´ì„¤ì—ì„œëŠ” ë³´ì„ì˜ ë¹ˆë„ìˆ˜ê°€ 0ì´ ë˜ë©´ mapì—ì„œ ë³´ì„ì„ ì•„ì˜ˆ ì œê±°í•œë‹¤ê³  ë‚˜ì™€ìˆë˜ë°, ê¶‚ì´ ë³´ì„ì„ ì œê±°í•  í•„ìš”ëŠ” ì—†ëŠ” ê²ƒ ê°™ë‹¤. ì²˜ìŒì— ìœ íš¨í•œ êµ¬ê°„ì„ ì°¾ì€ ë’¤, ê³„ì†í•´ì„œ ìœ íš¨í•œ êµ¬ê°„ì„ ìœ ì§€í•˜ëŠ” ë²”ìœ„ ë‚´ì—ì„œ í¬ì¸í„°ë¥¼ ì´ë™ì‹œí‚¤ë©´ ë˜ê¸° ë•Œë¬¸ì´ë‹¤.
```python
def solution(gems):
    gems_set = set(gems)
    gems_dict = {gems[0]: 1}
    start_idx = 0
    end_idx = 0
    min_length = float("inf")
    answer = [start_idx, end_idx]
    while end_idx < len(gems):
        if len(gems_dict) == len(gems_set):
            while gems_dict[gems[start_idx]] > 1:
                gems_dict[gems[start_idx]] -= 1
                start_idx += 1
            if end_idx - start_idx < min_length:
                min_length = end_idx - start_idx
                answer = [start_idx+1, end_idx+1]
        end_idx += 1
        if end_idx < len(gems):
            if gems[end_idx] not in gems_dict:
                gems_dict[gems[end_idx]] = 1
            else:
                gems_dict[gems[end_idx]] += 1
    return answer
```
<img src="2020_á„á…¡á„á…¡á„‹á…©_á„‹á…µá†«á„á…¥á†«á„‰á…µá†¸.assets/image-20200707010024766.png" alt="image-20200707010024766" style="zoom:33%;" />

ì°¸ê³ ) íˆ¬ í¬ì¸í„°ì™€ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¥¼ ì‚¬ìš©í•œ ë¬¸ì œë“¤ì´ [ì´ ë¸”ë¡œê·¸](https://m.blog.naver.com/kks227/220795165570)ì—ì„œ ì •ë¦¬ë˜ì–´ ìˆë‹¤. í•œë²ˆ í’€ì–´ë³´ë©´ì„œ ìµíˆë©´ ì¢‹ì„ ê²ƒ ê°™ë‹¤.

## 4. ê²½ì£¼ë¡œ ê±´ì„¤

ì²˜ìŒì—ëŠ” DFS í’€ì´ê°€ ë– ì˜¬ë¼ì„œ DFSë¡œ í’€ì—ˆëŠ”ë°, ì‹œê°„ì´ˆê³¼ í­íƒ„ ë§ì•˜ë‹¤. ğŸ¤¯

```python
from copy import deepcopy
import sys

sys.setrecursionlimit(1000000)
directions = [[0, -1, "H"], [0, 1, "H"], [1, 0, "V"], [-1, 0, "V"]]
answer = 0


def calculate_cost(x, y, n):
    if n == x or n == y:
        return ((n-x)+(n-y))*100
    else:
        return ((n-x)+(n-y))*100+500


def dfs(x, y, path, cost, board, visited):
    global directions, answer
    n = len(board)
    if answer != float("inf") and calculate_cost(x, y, n) > answer:
        return
    if x == n-1 and y == n-1:
        answer = min(cost, answer)
    for dx, dy, direction in directions:
        nx, ny = x+dx, y+dy
        if nx < 0 or nx > len(board)-1 or ny < 0 or ny > len(board)-1 or visited[nx][ny] or board[nx][ny]:
            continue
        visited[nx][ny] = 1
        if path == "":
            dfs(nx, ny, direction, cost+100, board, visited)
        elif direction != path:
            dfs(nx, ny, direction, cost+600, board, visited)
        else:
            dfs(nx, ny, direction, cost+100, board, visited)
        visited[nx][ny] = 0


def solution(board):
    global answer
    answer = float("inf")
    visited = [[0]*len(board) for _ in range(len(board))]
    dfs(0, 0, "", 0, board, visited)
    return answer


print(solution([[0, 0, 1, 0], [0, 0, 0, 0], [0, 1, 0, 1], [1, 0, 0, 0]]))
print(solution([[0, 0, 0], [0, 0, 0], [0, 0, 0]]))
```

<img src="2020_á„á…¡á„á…¡á„‹á…©_á„‹á…µá†«á„á…¥á†«á„‰á…µá†¸.assets/image-20200707224348091.png" alt="image-20200707224348091" style="zoom:33%;" />

ìµœë‹¨ ê²½ë¡œ ê¸¸ì°¾ê¸° ë¬¸ì œëŠ” DFS ë³´ë‹¤ **BFSê°€ í›¨ì”¬ íš¨ìœ¨ì´ ì¢‹ë‹¤**ê³  í•œë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ê¸¸ì°¾ê¸° ë¬¸ì œë¼ë©´ BFSë¥¼ ë¨¼ì € ê³ ë ¤í•˜ì.

ì¼ë°˜ì ì¸ BFSë¼ë©´ ìµœì´ˆë¡œ êµ¬í•´ì§€ëŠ” ê¸¸ì´ ìµœë‹¨ì´ì§€ë§Œ, ì´ ë¬¸ì œì—ì„œëŠ” ìµœë‹¨ ê²½ë¡œê°€ ì•„ë‹Œ **ìµœì†Œ cost** ë£¨íŠ¸ë¥¼ì°¾ì•„ì•¼ í•˜ë¯€ë¡œ ë‹¤ë¥¸ ì ‘ê·¼ì´ í•„ìš”í•˜ë‹¤.

[AC ë°›ì€ BFS í’€ì´]

```python
from collections import deque
from copy import deepcopy


def solution(board):
    global answer, directions
    answer = float("inf")
    n = len(board)
    visited = [[0]*len(board) for _ in range(n)]
    min_cost = [[float("inf")]*n for _ in range(n)]
    queue = deque([[0, 0, "", 0, visited]])
    directions = [[0, -1, "H"], [0, 1, "H"], [1, 0, "V"], [-1, 0, "V"]]
    while queue:
        current_position = queue.popleft()
        x, y, path, cost, visited = current_position
        if cost > min_cost[x][y]:
            continue
        else:
            min_cost[x][y] = cost
        if answer != float("inf") and cost > answer:
            continue
        if x == n-1 and y == n-1:
            answer = min(answer, cost)
            continue
        visited[x][y] = 1
        for dx, dy, direction in directions:
            nx, ny = x+dx, y+dy
            if nx < 0 or nx > n-1 or ny < 0 or ny > n-1 or visited[nx][ny] or board[nx][ny]:
                continue
            if path == "":
                next_cost = cost + 100
            elif direction != path:
                next_cost = cost + 600
            else:
                next_cost = cost + 100
            if next_cost > min_cost[nx][ny]:
                continue
            else:
                min_cost[nx][ny] = next_cost
            ck = deepcopy(visited)
            ck[nx][ny] = 1
            if path == "":
                queue.append([nx, ny, direction, next_cost, ck])
            elif direction != path:
                queue.append([nx, ny, direction, next_cost, ck])
            else:
                queue.append([nx, ny, direction, next_cost, ck])
    return answer
```

<img src="2020_á„á…¡á„á…¡á„‹á…©_á„‹á…µá†«á„á…¥á†«á„‰á…µá†¸.assets/image-20200708020011229.png" alt="image-20200708020011229" style="zoom: 33%;" />

ê³µì‹ í•´ì„¤ì„ ë³´ë‹ˆ ì—­ì‹œ ì œëŒ€ë¡œ ëœ í’€ì´ëŠ” ì•„ë‹Œ ê²ƒ ê°™ì€ë°, ì–´ì°Œì €ì°Œ ACëŠ” ë°›ì•˜ë‹¤.

[ë‹¤ë¥¸ í’€ì´]

```python
from collections import deque


def solution(board):
    n = len(board)
    min_cost = [[[float("inf") for _ in range(2)]
                 for _ in range(n)] for _ in range(n)]
    min_cost[0][0] = [0, 0]
    directions = [[1, 0, 0], [-1, 0, 0], [0, 1, 1], [0, -1, 1]]
    queue = deque([[0, 0, 0, 0]])
    while queue:
        [x, y, direction, cost] = queue.popleft()
        if cost > min_cost[x][y][direction]:
            continue
        for dx, dy, direct in directions:
            nx, ny = x+dx, y+dy
            if cost == 0:
                estimated_cost = 100
            else:
                if direction == direct:
                    estimated_cost = cost + 100
                else:
                    estimated_cost = cost + 600
            if nx < 0 or nx > n-1 or ny < 0 or ny > n-1 or board[nx][ny] or estimated_cost > min_cost[nx][ny][direct]:
                continue
            min_cost[nx][ny][direct] = estimated_cost
            queue.append([nx, ny, direct, estimated_cost])
    answer = min(min_cost[n-1][n-1])
    return answer
```

## 5. ë™êµ´ íƒí—˜

í’€ê³  ëˆˆë¬¼ ë‚ ë»” í–ˆìë‹ˆë‹¤ğŸ˜‚

2ê°€ì§€ í’€ì´ë¡œ í’€ì—ˆë‹¤.

### 1. ë°©í–¥ ê·¸ë˜í”„ì—ì„œ ì‚¬ì´í´ ì²´í¬í•˜ê¸°

```python
import sys
from collections import deque
sys.setrecursionlimit(10**9)


def set_adj_graph(path):
    adj_graph = [[] for _ in range(N)]
    for node_a, node_b in path:
        adj_graph[node_a].append(node_b)
        adj_graph[node_b].append(node_a)
    return adj_graph


def set_dir_graph(graph, order):
    dir_graph = [[] for _ in range(N)]
    # bfsë¡œ ë°©í–¥ ê·¸ë˜í”„ ë§Œë“¤ê¸°
    need_visit = deque([0])
    visited = [0 for _ in range(N)]
    while need_visit:
        curr_node = need_visit.popleft()
        visited[curr_node] = 1
        for adj_node in graph[curr_node]:
            if not visited[adj_node]:
                dir_graph[curr_node].append(adj_node)
                need_visit.append(adj_node)
    # orderë„ ì¶”ê°€í•´ì£¼ê¸°
    for prev_node, next_node in order:
        dir_graph[prev_node].append(next_node)
    return dir_graph


def is_cyclic(start_node):
    visited[start_node] = True
    in_dfs[start_node] = True
    for child_node in dir_graph[start_node]:
        if visited[child_node]:
            if in_dfs[child_node]:
                return True
            continue
        if is_cyclic(child_node):
            return True
    in_dfs[start_node] = False
    return False


def solution(n, path, order):
    global N, adj_graph, dir_graph, visited, in_dfs
    N = n
    adj_graph = set_adj_graph(path)
    dir_graph = set_dir_graph(adj_graph, order)
    visited = [0 for _ in range(N)]
    in_dfs = [0 for _ in range(N)]
    visited[0] = 1
    flag = is_cyclic(0)
    return False if flag else True


print(solution(9, [[0, 1], [0, 3], [0, 7], [8, 1], [3, 6],
                   [1, 2], [4, 7], [7, 5]], [[8, 5], [6, 7], [4, 1]]))
print(solution(9, [[0, 1], [0, 3], [0, 7], [8, 1], [3, 6],
                   [1, 2], [4, 7], [7, 5]], [[4, 1], [8, 7], [6, 5]]))
```

ë°±íŠ¸ë˜í‚¹ê³¼ ìœ ì‚¬í•œ ë°©ë²•ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

ë°©í–¥ ê·¸ë˜í”„ (dir_graph) ë¥¼ ë§Œë“¤ê³ , root ë…¸ë“œì¸ 0ì—ì„œë¶€í„° ì¶œë°œí•œë‹¤. ì¬ê·€ë¥¼ ì‚¬ìš©í•œ DFSë¡œ dir_graphë¥¼ ëŒë©´ì„œ, dir_graphì— ì‚¬ì´í´ì´ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ë¥¼ ì²´í¬í•˜ëŠ” ê²ƒì´ í¬ì¸íŠ¸ì´ë‹¤.

í˜„ì¬ ë°©ë¬¸í•œ ë…¸ë“œê°€ DFS ì¤‘ì¸ ë…¸ë“œë¼ë©´ ì‚¬ì´í´ì´ ìˆëŠ” ê²ƒì´ë‹¤. DFSë¥¼ í•˜ë‹¤ê°€ ì´ì „ ë…¸ë“œë¥¼ ë‹¤ì‹œ ë°©ë¬¸í•˜ëŠ” ì…ˆì´ ë˜ê¸° ë•Œë¬¸ì´ë‹¤.

ë”°ë¼ì„œ, DFS ì¤‘ì¸ (=ì•„ì§ DFSê°€ ì™„ë£Œë˜ì§€ ì•Šì€) ë…¸ë“œë¥¼ íŒë‹¨í•˜ê¸° ìœ„í•œ ë³€ìˆ˜ (`in_dfs`) ì™€ DFSê°€ ëë‚œ ë…¸ë“œë¥¼ ì €ì¥í•´ë‘ê¸° ìœ„í•œ ë³€ìˆ˜ (`visited`) 2ê°œë¥¼ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ í¬ì¸íŠ¸! In_dfsëŠ” ë°±íŠ¸ë˜í‚¹ì²˜ëŸ¼ DFSë¥¼ ë“¤ì–´ê°ˆ ë•Œ trueë¡œ ë°”ê¿”ì£¼ê³ , DFSê°€ ëë‚˜ê³  ë‚˜ì˜¬ ë•Œ falseë¡œ ë°”ê¿”ì£¼ì–´ì•¼ í•œë‹¤.

<img src="2020_á„á…¡á„á…¡á„‹á…©_á„‹á…µá†«á„á…¥á†«á„‰á…µá†¸.assets/image-20200729011015365.png" alt="image-20200729011015365" style="zoom: 33%;" />

### 2. ê°€ëŠ¥í•œ ë¶€ë¶„ë§Œ DFS ëŒê¸°

```python
# _*_ coding: utf-8 _*_
from collections import deque


def solution(n, path, order):
    need_visit = deque()
    answer = False
    visit = [0]*n
    visit[0] = 1
    cango = [0]*n
    cango[0] = 1
    parent_graph = {}
    child_graph = {}
    for prev_node, next_node in order:
        parent_graph[next_node] = prev_node
        child_graph[prev_node] = next_node
    graph = [[] for _ in range(n)]
    # graph ì™„ì„±í•´ì£¼ê¸° (ì–‘ë°©í–¥ ê·¸ë˜í”„)
    for prev_node, next_node in path:
        graph[prev_node].append(next_node)
        graph[next_node].append(prev_node)
    # root nodeì¸ 0ì´ ì„ í–‰ì§€ì ì´ ì—†ëŠ”ì§€ ì²´í¬í•´ì•¼ í•¨
    if parent_graph.get(0) is None:
        need_visit.extend(graph[0])
    while need_visit:
        curr_node = need_visit.popleft()
        cango[curr_node] = 1
        # curr_nodeë¥¼ ë°©ë¬¸í•˜ê¸° ìœ„í•œ ì„ í–‰ì§€ì ì´ ì—†ì„ ê²½ìš°
        if parent_graph.get(curr_node) is None:
            visit[curr_node] = 1
            for adj_node in graph[curr_node]:
                if visit[adj_node] == 0:
                    need_visit.append(adj_node)
            # curr_nodeì„ ì„ í–‰ì§€ì ìœ¼ë¡œ í•˜ëŠ” ë…¸ë“œê°€ ìˆê³ , í•´ë‹¹ ë…¸ë“œë¥¼ ê°ˆ ìˆ˜ ìˆëŠ” ê²½ìš°
            if child_graph.get(curr_node) is not None and cango[child_graph[curr_node]]:
                need_visit.append(child_graph[curr_node])
        else:
            # curr_nodeë¥¼ ë°©ë¬¸í•˜ê¸° ìœ„í•œ ì„ í–‰ì§€ì ì´ ìˆëŠ”ë°, ê·¸ ì„ í–‰ ì§€ì ì„ ë°©ë¬¸í–ˆì„ ê²½ìš°
            if visit[parent_graph.get(curr_node)] == 1:
                visit[curr_node] = 1
                for adj_node in graph[curr_node]:
                    if visit[adj_node] == 0:
                        need_visit.append(adj_node)
    if sum(visit) == n:
        answer = True
    return answer
```

DFSë¥¼ ì§„í–‰í•˜ë©°, ì•„ì§ ë°©ë¬¸í•  ìˆ˜ ì—†ëŠ” ì§€ì  (=ì„ í–‰ì§€ì ì„ ë°©ë¬¸í•˜ì§€ ëª»í•œ ì§€ì ) ì€ ì €ì¥í•´ë‘ê³  ë‚˜ì¤‘ì— ì„ í–‰ì§€ì ì„ ë°©ë¬¸í–ˆì„ ë•Œì— ë„ëŠ” ë°©ë²•ì´ë‹¤.

<img src="2020_á„á…¡á„á…¡á„‹á…©_á„‹á…µá†«á„á…¥á†«á„‰á…µá†¸.assets/image-20200802235717901.png" alt="image-20200802235717901" style="zoom:33%;" />



### [ì°¸ê³ ] ê·¸ë˜í”„ì—ì„œ ì‚¬ì´í´ ì²´í¬í•˜ê¸°

[[ê·¸ë˜í”„] ê·¸ë˜í”„ì—ì„œ ì‚¬ì´í´ ì°¾ëŠ” ë°©ë²•ë“¤(Detect Cycle in an Graph)](https://jackpot53.tistory.com/92)

[Cycle Detection Algorithm](https://kesakiyo.tistory.com/15)

#### ë°©í–¥ ê·¸ë˜í”„ì—ì„œ ì²´í¬í•˜ê¸°



#### ë¬´ë°©í–¥ ê·¸ë˜í”„ì—ì„œ ì²´í¬í•˜ê¸°

