# 2020 카카오 인턴십 코딩테스트
## 1. 키패드 누르기

간단한 조건문 문제지만, 실수하기 쉬운 문제. 시험 볼 때도 위치를 height (row) 만 저장해두는 실수를 했던 것 같은데, 다시 풀어볼 때도 똑같은 실수를 했다. `2,5,8,0` 을 눌렀을 때 왼손이 가까운지, 오른손이 가까운지를 확인하려면 **row와 column 위치를 둘 다 저장**해두어야 한다.

참고로 row는 `(num-1)//3` 과 값이 같고, column은 `(num-1)%3` 과 값이 같다는 규칙이 있다. 예를 들어 row는 1,2,3이 0이고, column은 1,4,7이 0이기 때문에. 각 숫자 별 행/열 위치를 하드코딩해도 되지만, 규칙을 사용하면 조금 더 간결하게 코드를 작성할 수 있다.

처음 손가락이 위치하는 곳은 따로 초깃값을 설정해주고, 위치를 계산해주는 함수를 따로 빼서 누른 숫자가 0일때만 예외적으로 위치를 리턴해줬다.

```python
# 숫자를 받아 위치(행,열)를 계산해주는 함수
def get_target_position(target):
    if target == 0:
        return [3, 1]
    else:
        return [(target-1)//3, (target-1) % 3]


def solution(numbers, hand):
  	# 초깃값 설정
    left_position = [3, 0]
    right_position = [3, 2]
    answer = ''
    for num in numbers:
        if num in [1, 4, 7]:
            answer += "L"
            left_position = get_target_position(num)
        elif num in [3, 6, 9]:
            answer += "R"
            right_position = get_target_position(num)
        else:
            target_position = get_target_position(num)
            # diff 를 비교한다
            left_diff = abs(
                left_position[0]-target_position[0]) + abs(left_position[1]-target_position[1])
            right_diff = abs(
                right_position[0]-target_position[0]) + abs(right_position[1]-target_position[1])
            if left_diff < right_diff:
                answer += "L"
                left_position = target_position
            elif left_diff > right_diff:
                answer += "R"
                right_position = target_position
            # 양 손의 거리가 같을 경우 hand를 확인한다
            else:
                if hand == "left":
                    answer += "L"
                    left_position = target_position
                else:
                    answer += "R"
                    right_position = target_position
    return answer


print(solution([7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2], "left"))
```



## 2. 수식 최대화

스택 사용하는 문제. expression을 돌면서 숫자와 연산자를 각각 분리해서 스택에 넣어주고, 스택을 돌면서 연산자 우선순위별로 연산하면 된다.

주의해야할 포인트는 아래와 같다.

- str, int 자료형 주의하기
- 연산한 결과를 어떻게 stack에 저장할 지
- 사용한 숫자는 어떻게 처리할지 (pop 할지, 다른 문자로 치환할지)

expression의 길이가 최대 100 밖에 안되고, 음수 숫자는 들어오지 않는다는 조건이 있어서 크게 어렵진 않다. input size가 작은 만큼 pop을 사용해도 될 것 같긴 하지만 나는 pop을 안쓰고 풀어보았다. 

연산자의 우선순위대로 한 개의 연산자마다 for 문으로 스택을 처음부터 돌면서, 해당 연산자를 만나면 eval을 통해 현재 인덱스 기준 prev 값과 next 값을 찾아 연산한다.

연산에 사용한 값은 다른 값들과 겹치지 않는 기호 (`_`) 로 변경하고, 별도의 함수를 만들어서 prev_idx와 next_idx를 찾을 때는 `_` 가 아닌 유효한 값이 있는 인덱스를 리턴하도록 했다.

pop을 하면 for 대신 while을 사용해야 하고, 유효한 prev, next index를 찾아내는 별도의 로직이 필요 없어지는 차이점이 있을 것 같다.

```python
from itertools import permutations
from copy import deepcopy


def find_prev_idx(stk, idx):
    for i in range(idx-1, -1, -1):
        if stk[i] != "_":
            return i


def find_next_idx(stk, idx):
    for i in range(idx+1, len(stk)):
        if stk[i] != "_":
            return i


def solution(expression):
    used_operator = []
    # 사용된 연산자 찾기
    for char in expression:
        if char in ["*", "-", "+"] and char not in used_operator:
            used_operator.append(char)
    # 모든 연산자 조합 구하기
    candidate_operation = permutations(used_operator)
    temp = ""
    stk = []
    # 숫자와 연산자로 분리해서 스택에 넣기
    for char in expression:
        if char in used_operator:
            stk.append(temp)
            stk.append(char)
            temp = ""
        else:
            temp += char
    stk.append(temp)
    answer = 0
    for candidate in candidate_operation:
        copied_stk = deepcopy(stk)
        # 우선순위 연산자별로 돌면서 계산해주기
        for operation in candidate:
            result = 0
            for idx in range(len(copied_stk)):
                if copied_stk[idx] == operation:
                    # _가 아닌 전후 인덱스 찾기
                    prev_idx = find_prev_idx(copied_stk, idx)
                    next_idx = find_next_idx(copied_stk, idx)
                    copied_stk[idx] = eval(
                        str(copied_stk[prev_idx])+copied_stk[idx]+str(copied_stk[next_idx]))
                    # 연산 결과를 result에 저장해 최종 값이 자동으로 result 변수에 저장되게 함
                    result = copied_stk[idx]
                    # 사용한 값은 _ 로 변경
                    copied_stk[prev_idx] = "_"
                    copied_stk[next_idx] = "_"
        answer = max(answer, abs(result))
    return answer
```



## 3. 보석 쇼핑

시험 볼 때 2시간 반이라는 시간이 남았음에도 못 풀었던 문제. 시험이 끝난 후 투 포인터로 푸는 문제라는 얘기를 듣고, 이번에 다시 풀어봤는데도 꽤 오랜 시간이 걸렸다.

### 내가 했던 실수

내가 했던 가장 큰 착각은 **최소 구간이 반드시 min, max 인덱스에서 나올 것이라는 착각**이었다. 여기서의 min, max 인덱스란 start_pointer이 될 수 있는 가장 max 값과 end_pointer이 될 수 있는 가장 min 값을 말한다.

다시 말하자면, 나는 각 보석이 등장한 횟수를 세면서, 등장한 보석의 종류 수가 달라지는 임계값 (end_idx를 끝 idx로 고정시켜 두었을 때 가능한 start_idx의 최대값, 그 때 가능한 end_idx의 최소값) 에서 최소 구간이 나올 것이라고 생각했다. 

이건 아주 잘못된 생각이다. 반례를 들어보자면

`1,2,4,1,1,3,1,1,2,3,4,4,3,4,4,2,1` 이라는 input이 주어졌을때, max_start_idx는 이후로 1,2,3,4가 적어도 한개 남아있는 [-5] 부분이고, min_end_idx는 이전에 1,2,3,4가 적어도 한개 남아있는 [5] 부분이다. 그런데 최소 길이는 [7:11] 구간인 `1,2,3,4`  이다.  이 구간은 min, max 인덱스와 아무런 상관이 없다.

생각해보면, min, max 인덱스는 가능한 범위의 범위만을 알려줄 뿐 (start_idx는 최대 몇, end_idx는 최소 몇) 그 안에서의 length는 직접 해보지 않으면 알 수가 없다.

### ac 받은 풀이

이 문제를 맞게 풀기 위해서는 **모든 지점을 탐색**하며 최적의 길이를 찾아야 한다. 투포인터를 이용한다면 O(n)의 시간복잡도로 답을 구할 수 있다.

```python
def solution(gems):
    gems_set = set(gems)
    gems_dict = {}
    min_length = float("inf")
    answer_arr = []
    start_idx = 0
    end_idx = 0
    # 가장 처음 나오는 유효한 구간 찾기
    for idx in range(len(gems)):
        if gems[idx] not in gems_dict:
            gems_dict[gems[idx]] = 1
            if len(gems_dict.keys()) == len(gems_set):
                end_idx = idx
                break
        else:
            gems_dict[gems[idx]] += 1
    while end_idx < len(gems):
        while gems_dict[gems[start_idx]] > 1:
            gems_dict[gems[start_idx]] -= 1
            start_idx += 1
        if min_length > end_idx - start_idx:
            answer_arr = [start_idx+1, end_idx+1]
            min_length = end_idx-start_idx
        end_idx += 1
        if end_idx < len(gems):
            gems_dict[gems[end_idx]] += 1
    return answer_arr
```

나는 일단 처음에 start_idx를 0으로 두고, end_idx를 증가시키며 가장 처음 나오는 유효한 구간을 찾았다.

그 이후로, end_idx가 끝에 도달할 때까지 아래 로직을 반복했다.

- start_idx가 가르키는 보석의 갯수가 1보다 크다면, 1이 될 때까지 start_idx를 증가시킨다. (idx가 증가함에 따라 보석의 갯수는 줄어든다)
- start_idx가 가르키는 보석의 갯수가 1이 되면, 구간의 길이를 재고 최소길이라면 답을 업데이트한다.
- end_idx를 1씩 증가시키고 해당하는 보석의 갯수를 증가시킨 뒤 처음 로직부터 반복한다.

즉, end_idx를 1씩 증가시키면서 **유효한 최소 구간 길이**를 계속해서 유지하는 방법이다. 처음에 유효한 구간으로 시작했으므로, start_idx가 가르키는 보석의 구간 내 갯수가 1이 되도록 유지하기만 한다면 계속해서 유효한 구간 (모든 보석이 적어도 1개 포함된 구간) 을 보장할 수 있다.

### 공식 해설 풀이

해설 역시 투 포인터로 풀었지만, 처음부터 start,end를 0,0에 두고 시작한다는 차이점이 있다.

```python

```



참고) 투 포인터와 슬라이딩 윈도우를 사용한 문제들을 [이 블로그](https://m.blog.naver.com/kks227/220795165570)에서 정리해 두었다. 한번 풀어보면서 익히면 좋을 것 같다.

