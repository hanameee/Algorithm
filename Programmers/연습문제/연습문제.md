## ê°€ì¥ í° ì •ì‚¬ê°í˜• ì°¾ê¸°

[ì²˜ìŒ **DFS**ë¡œ ì˜ëª» í‘¼ í’€ì´]

```python
import sys
sys.setrecursionlimit(10000000)
row_length, column_length = 0, 0


def is_quadrate(i, j, board, visited, count):
    global row_length, column_length
    visited[i][j] = 1
    result = count
    if i+1 >= row_length or j+1 >= column_length:
        return result
    else:
        if board[i+1][j] == 1 and board[i+1][j+1] == 1 and board[i][j+1] == 1:
            result = min(is_quadrate(i+1, j, board, visited, count+1), is_quadrate(
                i+1, j+1, board, visited, count+1), is_quadrate(i, j+1, board, visited, count+1))
    return result


def solution(board):
    global row_length, column_length
    answer = 0
    row_length = len(board)
    column_length = len(board[0])
    visited = [[0]*column_length for _ in range(row_length)]
    for i in range(row_length):
        for j in range(column_length):
            if not visited[i][j] and board[i][j]:
                answer = max(answer, is_quadrate(i, j, board, visited, 1))
    return answer**2
```

<img src="á„‹á…§á†«á„‰á…³á†¸á„†á…®á†«á„Œá…¦.assets/image-20200704010304712.png" alt="image-20200704010304712" style="zoom:33%;" />

[**DP**ë¥¼ ì‚¬ìš©í•´ì„œ ë‹¤ì‹œ í‘¼ í’€ì´]

```python
import copy
row_length, column_length = 0, 0


def is_quadrate(i, j, board, dp):
    global row_length, column_length
    if i-1 < 0 or j-1 < 0:
        return board[i][j]
    else:
        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1
        return dp[i][j]


def solution(board):
    global row_length, column_length
    answer = 0
    row_length = len(board)
    column_length = len(board[0])
    dp = copy.deepcopy(board)
    for i in range(row_length):
        for j in range(column_length):
            if dp[i][j]:
                answer = max(answer, is_quadrate(i, j, board, dp))
    return answer**2
```

í•œë²ˆ í’€ì–´ë³´ë‹ˆ ì´ ë¬¸ì œëŠ” í™•ì‹¤í•œ DPë‹¤. (ë¨¸ì“±)

ìƒê°í•´ë³´ë‹ˆ ì²˜ìŒì— DFSë¡œ í’€ ë•ŒëŠ” ê³„ì†í•´ì„œ ì¤‘ë³µ ê³„ì‚°ì´ ë˜ê²Œë” ì½”ë“œë¥¼ ì‘ì„±í–ˆë”ë¼. ck ë°°ì—´ì„ ë‘ì–´ì„œ í•œë²ˆ ê³„ì‚°í•œ ê³³ì€ ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•Šìœ¼ë ¤ê³  í–ˆëŠ”ë° ì´ë˜ë„ ì‹œê°„ì´ˆê³¼ê°€ ë‚˜ê³ , ë‹µë„ í‹€ë ¸ë‹¤.

ë‚´ê°€ 0,1,2,.... ì´ë ‡ê²Œ ìš°ì¸¡ ì•„ë˜ë¡œ íƒìƒ‰í•˜ëŠ”ë°, ì •ì‚¬ê°í˜•ì„ íŒë³„í•  ë•Œ `board[i+1][j], board[i+1][j+1], board[i][j+1]` ì„ ê°ê° í•¨ìˆ˜ë¥¼ ëŒë ¸ìœ¼ë‹ˆ... ë§¤ë²ˆ ì¤‘ë³µí•´ì„œ ê³„ì‚°ì´ ë  ìˆ˜ë°–ì—.

ìš°ì¸¡ ì•„ë˜ë¡œ íƒìƒ‰í•˜ë©´ì„œ, ê·¸ ì§€ì ì´ ì–´ë–¤ ì •ì‚¬ê°í˜•ì˜ ê°€ì¥ **ìš°ì¸¡ í•˜ë‹¨ ì§€ì **ì´ë¼ê³  ê°€ì •í•˜ê³  ê°€ëŠ¥í•œ ìµœëŒ€ ì •ì‚¬ê°í˜• ë³€ì˜ í¬ê¸°ë¥¼ DP ë°°ì—´ì— ì €ì¥í•œë‹¤ê³  ìƒê°í•˜ì.

ê·¸ëŸ¬ë©´ ê°„ë‹¨íˆ ë¡œì§ì€ `dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1])+1`  ì´ë‹¤. ë¬¼ë¡  ì¸ë±ìŠ¤ê°€ 0ë³´ë‹¤ ì‘ì•„ì§ˆë•ŒëŠ” ë”°ë¡œ ê³ ë ¤ë¥¼ í•´ì¤˜ì•¼ í•œë‹¤.

ìƒê°ë³´ë‹¤ ê¹Œë‹¤ë¡œì› ë˜ ë¬¸ì œì´ë‹¤.

## ë•…ë”°ë¨¹ê¸°

ì´ê²ƒë„ ê·¸ë¦¬ë””ê°€ ì•„ë‹ˆë¼ DPì˜€ì–´... ì—°ìŠµë¬¸ì œë¼ê³  ë§Œë§Œí•˜ê²Œ ë³´ë‹¤ê°€ í‹€ë¦¬ëŠ” ë¬¸ì œë“¤ì´ ê½¤ ìˆëŠ” ê²ƒ ê°™ë‹¤. ğŸ¤¯

```python
import copy


def solution(land):
    dp = copy.deepcopy(land)
    dp[0] = land[0]
    for row_idx in range(1, len(land)):
        for col_idx in range(4):
            max_prev_value = 0
            for prev_col_idx in range(4):
                if col_idx != prev_col_idx:
                    max_prev_value = max(
                        max_prev_value, dp[row_idx-1][prev_col_idx])
            dp[row_idx][col_idx] += max_prev_value
    return max(dp[-1])


print(solution([[1, 2, 3, 5], [5, 6, 7, 8], [4, 3, 2, 1]]))
```

columnì˜ ìµœëŒ€ ê¸¸ì´ê°€ 4ë°–ì— ì•ˆë˜ê¸° ë•Œë¬¸ì—, ë§¤ë²ˆ max ê°’ì„ ì°¾ì•„ë„ ì‹œê°„ì´ˆê³¼ê°€ ëœ¨ì§€ ì•ŠëŠ” ê²ƒ ê°™ë‹¤.



## JadenCase ë¬¸ìì—´ ë§Œë“¤ê¸°
ì´ì¹œêµ¬ ì—­ì‹œ í•¨ì •ì¹´ë“œê°€ ìˆì—ˆë‹¤.

1. ì—°ì†ëœ ê³µë°±ì´ ìˆì„ ìˆ˜ ìˆë‹¤. sì˜ ì‹œì‘ê³¼ ëì— í•˜ë‚˜ ì´ìƒì˜ ê³µë°±ì´ ìˆì„ ìˆ˜ ìˆë‹¤.
2. ë¬¸ìì—´ì´ 1ê¸€ìì¼ ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ ë¶„ê¸°ì²˜ë¦¬ë¥¼ í•´ì¤˜ì•¼ í•œë‹¤.

```python
def solution(s):
    result = ""
    buff = ""
    for char in s:
        if char == " ":
            if len(buff) > 0:
                if len(buff) > 1:
                    result += buff[0].upper() + buff[1:].lower()
                else:
                    result += buff[0].upper()
            buff = ""
            result += " "
        else:
            buff += char
    if len(buff) > 1:
        result += buff[0].upper() + buff[1:].lower()
    elif len(buff) == 1:
        result += buff[0].upper()
    return result
```

ì˜ˆì‹œ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë§Œ ë³´ë©´, `s.split(" ")` ë¥¼ í•˜ê³  ì‹¶ì€ ë§ˆìŒì´ ì”ëœ© ë“¤ì§€ë§Œ ê·¸ë ‡ê²Œ í•˜ë©´ ì˜ˆì™¸ì²˜ë¦¬ê°€ ì•„ì£¼ í˜ë“¤ë‹¤. ì—¬ëŸ¬ê°œì˜ ê³µë°±ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•´ì•¼ í•˜ëŠ”ë°, ê³µë°±ì„ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ ë²„ë¦¬ë©´ ì´ë¥¼ íŒŒì•…í•˜ê¸°ê°€ ì‰½ì§€ ì•Šë‹¤.

ë” ì§ê´€ì ì¸ ë°©ë²•ì€ sì˜ ëª¨ë“  ë¬¸ìì—´ì„ í•˜ë‚˜í•˜ë‚˜ ëŒë©´ì„œ ê³µë°±ì´ë©´ ê·¸ëŒ€ë¡œ resultì— ë”í•´ì£¼ê³ , ê³µë°±ì´ ì•„ë‹ˆë©´ bufferì— ì¶”ê°€í•˜ëŠ” ê²ƒì´ë‹¤. bufferì´ ì°¨ìˆëŠ”ë° ê³µë°±ì„ ë§Œë‚¬ë‹¤ë©´ ì´ëŠ” í•˜ë‚˜ì˜ ë¬¸ìë¬¶ìŒì´ ëë‚¬ë‹¤ëŠ” ëœ»ì´ë¯€ë¡œ bufferì„ JadenCaseë¡œ ë³€í™˜í•´ resultì— ì¶”ê°€í•´ì¤€ ë’¤ bufferì„ ë¹„ìš´ë‹¤.

ì´ë•Œ, ë¬¸ìë¬¶ìŒì´ 1ì¼ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ë¶„ê¸°ì²˜ë¦¬ë¥¼ í•´ì¤˜ì•¼ í•œë‹¤.

ë˜, sì˜ ëª¨ë“  ë¬¸ìì—´ì„ ë‹¤ ëˆ ì´í›„ì—ë„ bufferì´ ì°¨ìˆë‹¤ë©´ í•´ë‹¹ ë§ˆì§€ë§‰ ë¬¸ìë¬¶ìŒê¹Œì§€ ì²˜ë¦¬í•´ì£¼ì–´ì•¼ í•œë‹¤.



## Nê°œì˜ ìµœì†Œê³µë°°ìˆ˜

```python
def get_primes(n):
    arr = [0, 0] + [1]*(n-1)
    for i in range(2, int(n**0.5)+1):
        if not arr[i]:
            continue
        j = 2
        while i*j <= n:
            arr[i*j] = 0
            j += 1
    result_arr = []
    for _ in range(2, n+1):
        if arr[_]:
            result_arr.append(_)
    return(result_arr)


def get_divisor(n):
    for prime in prime_arr:
        if n % prime == 0:
            i = 1
            n = n//prime
            while n % prime == 0:
                n = n//prime
                i += 1
            if prime in divisor_dict and divisor_dict[prime] >= i:
                continue
            else:
                divisor_dict[prime] = i
        if prime > n:
            return


def solution(arr):
    global divisor_dict, prime_arr
    prime_arr = get_primes(100)
    divisor_dict = {}
    for num in arr:
        get_divisor(num)
    answer = 1
    for key in divisor_dict.keys():
        answer *= key**divisor_dict[key]
    return answer
```

ìµœì†Œê³µë°°ìˆ˜ ê³µì‹ì„ ê¹Œë¨¹ì–´ì„œ ë¹™ë¹™ ëŒì•„ì„œ í’€ì—ˆë‹¤.

