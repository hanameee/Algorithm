# 9. 동적 프로그래밍 (2)

## 9251. LCS

문제 유형: `동적 프로그래밍, LCS`, 난이도: `하`

최장 공통 부분수열로 교과서에서도 나올 정도로 기본적이고 자주 출제되는 문제. 다른 문제를 풀 때도 많이 운용될 수 있기에 중요하다.

### 문제 풀이 아이디어

1) 가장 긴 공통 부분 수열(LCS) 문제로 알려진 대표적인 동적 프로그래밍 문제
2) 두 수열의 길이가 N 미만일 때, 시간 복잡도 O(N^2) 으로 문제를 해결할 수 있음
3) 두 수열을 각각 X,Y라고 하면 D[i]\[j] 는 X[0...j]Y[0...j]의 공통 부분 수열의 최대 길이

####  내가 작성한 코드

어렵다 어려워 🤯
0/1 Knapsack 문제와 유사하다.

```python
import sys
x = sys.stdin.readline().strip()
y = sys.stdin.readline().strip()
lcs = [[0]*(len(y)+1) for _ in range(len(x)+1)]

for i in range(1, len(x)+1):
    for j in range(1, len(y)+1):
        if x[i-1] == y[j-1]:
            lcs[i][j] = max(lcs[i-1][:j]) + 1
        else:
          	# 이걸 안해주면 직전에 일치하지 않는 알파벳 (ex.Y) 가 나왔을 때 lcs[i-1]가 다 0이 되어서 max(lcs[i-1]) 도 0이 되어버림.
            # 직전에 일치하지 않는 알파벳이 있어도 최장수열은 이전까지의 최장수열과 같기 때문에
            lcs[i][j] = lcs[i-1][j]  

print(max(lcs[-1]))
```

#### 개선한 코드

시간은 더 걸리는게 개꿀잼몰카

```python
import sys
x = sys.stdin.readline().strip()
y = sys.stdin.readline().strip()
lcs = [[0]*(len(y)+1) for _ in range(len(x)+1)]

for i in range(1, len(x)+1):
    none = True
    for j in range(1, len(y)+1):
        if x[i-1] == y[j-1]:
            lcs[i][j] = lcs[i-1][j-1] + 1 # lcs[i-1][j] 아니다. 결과를 보고 규칙을 찾지 말고, 로직을 생각해야 한다! ACA, AAA 생각해보면 됨
            none = False
        else:
            lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1]) # 값이 다르다면 둘 중 비교해서 더 큰 값을 넣는다
    if none:
        lcs[i] = lcs[i-1]

print(max(lcs[-1]))
```

#### 답안 코드

점화식은

![image-20200330202432590](9_동적 프로그래밍(2).assets/image-20200330202432590.png)

```python
x = input()
y = input()

dp = [[0] * (len(y) + 1) for _ in range(len(x) + 1)]

for i in range(1, len(x) + 1):
	for j in range(1, len(y) + 1):
		if x[i - 1] == y[j - 1]:
			dp[i][j] = dp[i - 1][j - 1] + 1
    else:
      dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])

print(dp[len(x)][len(y)])
```
### Lesson learned

- 초기화 해줄 때 **공집합도 포함**해서 초기화해주기
- lcs[x]\[y]니까 그림 그릴때도 **X를 행으로 Y를 열**으로 index 놓고 그리면 편하다
- **결과를 보고 규칙을 찾지 말고, 로직을 생각해야 한다.**

---

## 1495. 기타리스트 ⭐️

문제 유형: `동적 프로그래밍` 난이도: `중`

### 문제 풀이 아이디어

1) 차례대로 곡을 연주한다는 점에서, 동적 프로그래밍으로 해결할 수 있는 문제 (작은 것부터 해결하니까)
2) 곡의 개수 N, 볼륨 최댓값을 M이라고 했을 때 **O(NM)** 으로 문제를 해결할 수 있다

#### 🚫 내가 작성한 코드 (런타임에러)

0/1 Knapsack 때처럼 현재볼륨 i, 볼륨차 j 일때 dp[i]\[j] 를 가능한 볼륨의 값들로 싹 다 저장해둔 뒤 풀려고 했는데 런타임 에러 뜸. 잘못된 접근 방식이었던 것 같다.

점화식이 안나왔잖아. **점화식을 도출해 내는 것이 DP의 핵심**

```python
import sys 

n, s, m = map(int, sys.stdin.readline().split())
v = list(map(int, sys.stdin.readline().split()))
dp = [[0]*(m+1) for _ in range(m+1)]
current = [[] for _ in range(n)]

for i in range(0, m+1):  # 현재볼륨
    for j in range(0, m+1):  # 볼륨차
        a = i + j
        b = i - j
        dp[i][j] = []
        if 0 <= a and a <= m:
            dp[i][j].append(a)
        if 0 <= b and b <= m:
            dp[i][j].append(b)
        if len(dp[i][j]) == 0:
            dp[i][j] = [-1]


if dp[s][v[0]] == [-1]:
    print(-1)
    exit(0)
else:
    current[0] = dp[s][v[0]]


for i in range(1, n):
    flag = False
    for value in current[i-1]:
        for nextValue in dp[value][v[i]]:
            if nextValue != -1:
                flag = True
            else:
                continue
            if nextValue not in current[i]:
                current[i].append(nextValue)
    if not flag:
        print(-1)
        exit(0)


print(max(current[-1]))
```

#### 수정한 코드

```python
import sys

n, s, m = map(int, sys.stdin.readline().split())
v = list(map(int, sys.stdin.readline().split()))
dp = [[False]*(m+1) for _ in range(n+1)]
dp[0][s] = True

for i in range(1, n+1):
    flag = False
    for j in range(m+1):
        if dp[i-1][j] == True:
            if j+v[i-1] <= m:
                dp[i][j+v[i-1]] = True
                flag = True
            if j-v[i-1] >= 0:
                dp[i][j-v[i-1]] = True
                flag = True
    if flag == False:
        print(-1)
        sys.exit(0) # 그냥 exit(0) 하면 에러나고, sys.exit(0) 을 해야 한다. 채앰놰...

result = -1
for volume in range(m, -1, -1):
    if dp[n][volume] == True:
        result = volume
        break

print(result)
```



#### 답안 코드

핵심 아이디어는 **모든 볼륨에 대하여 연주 가능 여부를 계산**하기
D[i]\[j+1] = i번째 노래일 때, j크기의 볼륨으로 연주 가능한지 여부 (True/False로)

곡이 바뀔때마다 노래를 순서대로 확인하며, 매번 모든 크기의 볼륨 (1~M까지)에 대하여 검사

![image-20200331031642615](9_동적 프로그래밍(2).assets/image-20200331031642615.png)

```python
n, s, m = map(int, input().split())
array = list(map(int,input().split()))

dp = [[0]*(m+1) for _ in range(n+1)]
dp[0][s] = 1

for i in range(1, n+1):
  for j in range(m+1):
    if dp[i-1][j] == 0:
      continue
    if j-array[i-1] >= 0:
      dp[i][j-array[i-1]] = 1
    if j+array[i-1] <= m:
      dp[i][j+array[i-1]] = 1
 result = -1

for i in range(m, -1, -1):
  if dp[n][i] == 1:
    result = i
    break
    
print(result)
```
인덱스가 많이 헷갈렸다. 테이블에 index 꼭꼭 써두고 차근히 풀기.
#### Lesson learned

1. range 함수 사용법 복습
   **range(start, end, 격차)** : end 인덱스는 안들어간다. range(10,-1,-1) 은 10부터 0까지다.
2. exit(0) 말고 sys.exit(0)
   이것 때문에 계속 런타임 에러나서 고생
3. DP에서 어떤걸 메모이제이션 할 지 생각할때 **어떤게 고정**되어 있는지, 그리고 **어떤게 이전 단계를 기반으로 계산**되는지 생각. 이 문제에서는 n+1번째 곡의 볼륨이 n번째의 곡의 볼륨에 영향을 받으므로 n이 dp의 한 부분으로 들어간다는걸 유추할 수 있고, 볼륨은 항상 1000이하의 고정된 값이므로 나머지 dp의 테이블이 볼륨 사이즈 만큼 들어간다는 것을 유추할 수 있다. 연습하자!

----

