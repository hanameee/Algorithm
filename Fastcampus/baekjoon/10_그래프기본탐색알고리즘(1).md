# 10. ê·¸ë˜í”„ ê¸°ë³¸ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ (1)

ìì£¼ ë‚˜ì˜¤ê³  ì •í˜•í™” ë˜ì–´ ìˆëŠ” ì½”ë“œì´ë¯€ë¡œ ë§ì´ í’€ì–´ë³¼ ê²ƒ

## 1260. DFSì™€ BFS

ë¬¸ì œ ìœ í˜•: `DFS, BFS`, ë‚œì´ë„: `í•˜`

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

1) ê¸°ë³¸ì ì¸ í˜•íƒœì˜ ê·¸ë˜í”„ë¥¼ ë‹¨ìˆœíˆ DFS, BFSë¡œ íƒìƒ‰
2) **ì •ì  ë²ˆí˜¸ê°€ ì‘ì€ ê²ƒì„ ë¨¼ì € ë°©ë¬¸**í•´ì•¼ í•¨ - ì¶”ê°€ì ìœ¼ë¡œ ì •ë ¬ í•´ ì¤„ í•„ìš”ê°€ ìˆìŒ
3) ëª¨ë“  ë…¸ë“œì™€ ê°„ì„ ì„ ì°¨ë¡€ëŒ€ë¡œ ì¡°íšŒí•˜ì—¬ **O(N+M)** ì˜ ì‹œê°„ ë³µì¡ë„ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•´ì•¼ í•¨
4) ì´ëŸ° ë¬¸ì œëŠ” ë§¤ìš° ë¹¨ë¦¬ í’€ ìˆ˜ ìˆë„ë¡ ìˆ™ë‹¬í•´ì•¼ í•¨. ì •í˜•í™” ë˜ì–´ ìˆëŠ” ì½”ë“œì´ë¯€ë¡œ **ê±°ì˜ ì™¸ìš¸ ì •ë„**ë¡œ!
5) í (Queue) êµ¬í˜„ì„ ìœ„í•´ì„œ **collections ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ deque**ë¥¼ ì‚¬ìš©í•¨

####  ğŸš« ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ (ëŸ°íƒ€ì„ ì—ëŸ¬)

```python
import sys

n, m, v = map(int, sys.stdin.readline().split())
graph = [[] for i in range(n+1)]

for i in range(m):
    node_a, node_b = map(int, sys.stdin.readline().split())
    graph[node_a].append(node_b)
    graph[node_b].append(node_a)

adj_queue = []
adj_stack = []
visited = []


def dfs(start_node):
    visited.append(start_node)
    adj = sorted(graph[start_node], reverse=True)
    adj_stack.extend(adj)
    while adj_stack:
        node = adj_stack.pop()
        if node not in visited:
            return dfs(node)
    return


def bfs(start_node):
    visited.append(start_node)
    adj = sorted(graph[start_node])
    adj_queue.extend(adj)
    while adj_queue:
        node = adj_queue.pop(0)
        if node not in visited:
            return bfs(node)
    return


dfs(v)
for node in visited:
    print(node, end=' ')

print()
visited = []

bfs(v)
for node in visited:
    print(node, end=' ')
```

ì¬ê·€ë¥¼ ì‚¬ìš©í–ˆë”ë‹ˆ ëŸ°íƒ€ì„ ì—ëŸ¬ ë°œìƒ ğŸ¤¯

íŒŒì´ì¬ì—ì„œ ì¬ê·€ë¡œ DFSë¥¼ êµ¬í˜„í–ˆì„ ë•Œ stack size ì´ˆê³¼ë¡œ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤ê³  í•œë‹¤.
ì•„ë˜ì²˜ëŸ¼ ì¬ê·€ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  êµ¬í˜„í•  ìˆ˜ ìˆìŒ!

#### âœ… ìˆ˜ì •í•œ ì½”ë“œ

```python
import sys

n, m, v = map(int, sys.stdin.readline().split())
graph = [[] for i in range(n+1)]

for i in range(m):
    node_a, node_b = map(int, sys.stdin.readline().split())
    graph[node_a].append(node_b)
    graph[node_b].append(node_a)

adj_queue = []
adj_stack = []
visited = []


def dfs(start_node):
    visited.append(start_node)
    adj = sorted(graph[start_node], reverse=True)
    adj_stack.extend(adj)
    while adj_stack:
        node = adj_stack.pop()
        if node not in visited:
            visited.append(node)
            adj = sorted(graph[node], reverse=True)
            adj_stack.extend(adj)
    return


def bfs(start_node):
    visited.append(start_node)
    adj = sorted(graph[start_node])
    adj_queue.extend(adj)
    while adj_queue:
        node = adj_queue.pop(0)
        if node not in visited:
            visited.append(node)
            adj = sorted(graph[node])
            adj_queue.extend(adj)
    return


dfs(v)
for node in visited:
    print(node, end=' ')

print()
visited = []

bfs(v)
for node in visited:
    print(node, end=' ')
```
#### ë‹µì•ˆ ì½”ë“œ

í ì‚¬ìš©ì„ ìœ„í•´ collections ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ **deque** (ë±) ì‚¬ìš©
ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ì„œ íì²˜ëŸ¼ ì“°ë©´ ë¹„íš¨ìœ¨ì ì´ë¯€ë¡œ deque ë¥¼ ì´ìš©í•˜ëŠ”ê±¸ ì¶”ì²œ

```python
from collections from deque

# ì´ë¡ ì ìœ¼ë¡œëŠ” ìŠ¤íƒì„ ì´ìš©í•´ì„œ ê¹Šì´ ìš°ì„  íƒìƒ‰ìœ¼ë¡œ, ì‹¤ì „ì—ì„œëŠ” ì¬ê·€ë¥¼ ì´ìš©í•´ ê°„ë‹¨íˆ
def dfs(v):
  print(v, end=' ')
  visited[v] = True
  for e in adj[v]:
    if not(visited[e]):
      dfs(e)

# bfsëŠ” í ê¼­ í•„ìš”
def bfs(v):
  q = deque([v])
  while q:
    v = q.popleft()
    if not(visited[v]):
      visited[v] = True
      print(v, end=' ')
      for e in adj[v]:
        if not visited[e]:
          q.append(e)

n, m, v = map(int, input().split())
adj = [[] for _ in range(n+1)] # ì¸ì ‘í•œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë‹´ëŠ”ë‹¤

for _ in range(m):
  x,y = map(int, input().split())
  adj[x].append(y)
  adj[y].append(x)

for e in adj:
  e.sort() # ì •ë ¬ì„ ë‹¤ í•´ì¤˜ì„œ ë‚˜ì¤‘ì— íƒìƒ‰í•  ë•Œ ê°€ì¥ ë‚®ì€ ë²ˆí˜¸ë¶€í„° ë°©ë¬¸í•˜ë„ë¡

# visited ë°°ì—´ì„ ì‚¬ìš©í•´ì„œ í•œë²ˆ ë°©ë¬¸í•œ ë°°ì—´ì€ ë°©ë¬¸í•˜ì§€ ì•Šë„ë¡ í•¨
visited = [False] * (n+1) # n+1ê°œë¥¼ ë¯¸ë¦¬ ë‹¤ ì´ˆê¸°í™” í•´ë†“ëŠ”êµ°
dfs(v)
print()
visited = [False] * (n+1)
bfs(v)
```
#### ë‹µì•ˆ ë³´ê³  2ì°¨ë¡œ ìˆ˜ì •í•œ ì½”ë“œ

visitedë¥¼ ë¹ˆ ë°°ì—´ë¡œ ê´€ë¦¬í•˜ëŠ” ê²ƒë³´ë‹¤, node ë§Œí¼ì˜ ë°°ì—´ë¡œ ë¯¸ë¦¬ ì¡ì•„ë‘ê³  T/Fë¡œ ì²´í¬í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤!

```python
import sys
from collections import deque


n, m, v = map(int, sys.stdin.readline().split())
graph = [[] for i in range(n+1)]

for i in range(m):
    node_a, node_b = map(int, sys.stdin.readline().split())
    graph[node_a].append(node_b)
    graph[node_b].append(node_a)

adj_queue = deque([])
adj_stack = []
visited = [False for _ in range(n+1)]


def dfs(start_node):
    visited[start_node] = True
    print(start_node, end=' ')
    adj = sorted(graph[start_node], reverse=True)
    adj_stack.extend(adj)
    while adj_stack:
        node = adj_stack.pop()
        if visited[node] == False:
            visited[node] = True
            print(node, end=' ')
            adj = sorted(graph[node], reverse=True)
            adj_stack.extend(adj)
    return


def bfs(start_node):
    visited[start_node] = True
    print(start_node, end=' ')
    adj = sorted(graph[start_node])
    adj_queue.extend(adj)
    while adj_queue:
        node = adj_queue.popleft()
        if visited[node] == False:
            visited[node] = True
            print(node, end=' ')
            adj = sorted(graph[node])
            adj_queue.extend(adj)
    return


dfs(v)
print()

visited = [False for _ in range(n+1)]

bfs(v)

```
---

## 1697. ìˆ¨ë°”ê¼­ì§ˆ â­ï¸

ë¬¸ì œ ìœ í˜•: `BFS` ë‚œì´ë„: `í•˜`

ëŒ€í‘œì ì¸ BFS ë¬¸ì œ.

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

1) íŠ¹ì • ìœ„ì¹˜ê¹Œì§€ ì´ë™í•˜ëŠ” ìµœë‹¨ ì‹œê°„ì„ ê³„ì‚°í•´ì•¼ í•˜ëŠ” ë¬¸ì œ
2) ì´ë™ ì‹œê°„ì´ ëª¨ë‘ 1ì´ˆë¡œ ë™ì¼í•˜ë¯€ë¡œ (**ê·¸ë˜í”„ì˜ ëª¨ë“  ê°„ì„ ì˜ ê¸¸ì´ê°€ 1**), BFS ì´ìš©í•˜ì—¬ í•´ê²° ê°€ëŠ¥
3) í êµ¬í˜„ì„ ìœ„í•´ collections ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ deque ì‚¬ìš©

#### ğŸš« ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ (í‹€ë¦¼)

bfs ì˜ levelì„ ì–´ë–»ê²Œ êµ¬í•˜ì§€..?

```python
from collections import deque
import sys

graph = [[] for i in range(100001)]
visited = [False for i in range(100001)]

n, k = map(int, sys.stdin.readline().split())

for i in range(100001):
    if i <= 50000:
        graph[i] = [i-1, i+1, 2*i]
    else:
        graph[i] = [i-1, i+1]

if n != k:
    visited[i] = True
    adj = deque(graph[i])
    step = 0
    while adj:
        node = adj.popleft()
        step += 1
        if node == k:
            print(step)
            sys.exit(0)
        if not visited[node]:
            visited[node] = True
            adj.extend(graph[node])

print(step)
```

#### ë‹µì•ˆ ì½”ë“œ

ì•Œê³ ë¦¬ì¦˜ì—ì„œ dfs, bfs ë‚˜ì˜¤ëŠ” ê²½ìš° ì•„ë˜ì˜ í‹€ì„ í¬ê²Œ ë²—ì–´ë‚˜ì§€ ì•ŠìŒ.

- ì¼ë‹¨ ê·¸ë˜í”„ë¥¼ ë¯¸ë¦¬ ë‹¤ ë§Œë“¤ì–´ ë†“ëŠ” ê²ƒì´ ì•„ë‹ˆê³ , ì‹œì‘ ì •ì ì´ ì£¼ì–´ì§€ë©´ ê±°ê¸°ì„œë¶€í„° ê°„ì„ ë“¤ì„ íƒìƒ‰í•˜ëŠ” ê²ƒ. DPê°€ ì•„ë‹ˆë€ë‹¤ í•´ë‚˜ì•¼?

```python
from collections import deque
import sys

MAX = 100001
array = [0] * MAX
n, k = map(int, sys.stdin.readline().split())

def bfs():
  q = deque([n])
  while q:
    now_pos = q.popleft()
    if now_pos == k:
      return array[now_pos]
    # ì´ë™í•  ìˆ˜ ìˆëŠ” ê±°ë¦¬ê°€ 3ê°€ì§€ ë¿ì´ê¸°ì—, 3ê°€ì§€ ê²½ìš°ë¡œ ë‹¤ìŒ ì •ì ë“¤ì„ í•´ê²°í•  ìˆ˜ ìˆìŒ
   	for next_pos in (now_pos-1, now_pos+1, now_pos*2):
      # ë²”ìœ„ì— í¬í•¨ë˜ì–´ ìˆê³  ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
      if 0 <= next_post < MAX and not array[next_pos]:
        array[next_pos] = array[now_pos] + 1 # ìµœì†Œì‹œê°„ì— ëŒ€í•œ ì •ë³´ë¥¼ arrayì— ë‹´ì•„ì£¼ê³ 
        # ë‹¤ì‹œ qì— ë„£ì–´ì¤˜ì„œ ë°˜ë³µì ìœ¼ë¡œ dfs ìˆ˜í–‰
        q.append(next_pos)

print(bfs())
```

ì‹œê°„ ë³µì¡ë„ëŠ” ì •ì +ê°„ì„  ê°¯ìˆ˜

### ìˆ˜ì •í•œ ì½”ë“œ

ì‰½ê²Œ ìƒê°í•˜ë©´, ê¸°ì¡´ì— DFSì™€ BFSì—ì„œ ê´€ë¦¬í•˜ë˜ visited ë¦¬ìŠ¤íŠ¸(í)ë¥¼ T/Fë‚˜ ì¸ë±ìŠ¤ ë²ˆí˜¸ê°€ ì•„ë‹Œ, level ë²ˆí˜¸ë¡œ ê´€ë¦¬í•˜ëŠ” ê²ƒ.

ë˜í•œ, ë¯¸ë¦¬ ê·¸ë˜í”„ë¥¼ ë§Œë“¤ì–´ ë†“ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ì‹œì‘ ì •ì ì—ì„œ ì´ë™í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ 3ê°€ì§€ì´ë¯€ë¡œ ë§¤ë²ˆ forë¬¸ì„ ëŒ ë•Œë§ˆë‹¤ ê·¸ 3ê°€ì§€ caseì— ëŒ€í•´ ë²”ìœ„ ì¡°ê±´ ì²´í¬ ë° ì´ë¯¸ ë°©ë¬¸í•œ ì •ì ì¸ì§€ í™•ì¸ í›„, queueì— ë„£ì–´ì£¼ê³  depth ì—…ë°ì´íŠ¸ í•´ì£¼ê¸°.

```python
import sys
from collections import deque

n, k = map(int, sys.stdin.readline().split())
MAX = 100001
depth = [0 for _ in range(MAX)]
queue = deque([n])


def dfs():
    while queue:
        current_node = queue.popleft()
        if current_node == k:
            return depth[current_node]
        for next_node in [current_node-1, current_node+1, current_node*2]:
            if 0 <= next_node < MAX and depth[next_node] == 0:
                queue.append(next_node)
                depth[next_node] = depth[current_node] + 1


print(dfs())
```

### 2ì°¨ë¡œ ìˆ˜ì •í•œ ì½”ë“œ

ë‚˜ì¡ì•„ë´ë¼ í’€ì–´ë³¸ ë’¤ ì¶”ê°€ëœ ë¶€ë¶„ë§Œí¼ë§Œ for ë¬¸ì„ ì‚¬ìš©í•´ ë°˜ë³µí•˜ê³ , timeì„ += 1 í•´ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ ì§„í–‰. ë” ì§ê´€ì ì¸ ê²ƒ ê°™ë‹¤.

```python
import sys
from collections import deque


def bfs():
    n, k = map(int, sys.stdin.readline().split())
    limit = 100000
    visited = [0 for _ in range(limit+1)]
    queue = deque([n])
    time = 0
    while True:
        for i in range(len(queue)):
            current_node = queue.popleft()
            if current_node == k:
                return time
            for next_node in [current_node-1, current_node+1, current_node*2]:
                if 0 <= next_node <= limit and not visited[next_node]:
                    queue.append(next_node)
                    visited[next_node] = True
        time += 1


print(bfs())
```

visitedëŠ” T/Fë¡œë§Œ í•˜ê³  ë³€ìˆ˜ë¡œ í˜„ì¬ ì‹œê°„ì„ ê´€ë¦¬.