# 10. ê·¸ë˜í”„ ê³ ê¸‰ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜


## 10282. í•´í‚¹

ë¬¸ì œ ìœ í˜•: `ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ê²½ë¡œ`, ë‚œì´ë„: `ì¤‘`

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

- ê¸°ë³¸ì ì¸ ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ
- ë„ë‹¬í•  ìˆ˜ ìˆëŠ”n ì •ì ë“¤ì˜ ê°œìˆ˜ì™€ ê±°ë¦¬ë¥¼ ì¶œë ¥
- ì •ì ì˜ ê°œìˆ˜ Nì´ ìµœëŒ€ 10,000ì´ê³ , ê°„ì„ ì˜ ê°œìˆ˜ DëŠ” ìµœëŒ€ 100,000
- ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•˜ì—¬ ì‹œê°„ ë³µì¡ë„ëŠ” O(NlogD) ë¡œ í•´ê²°í•  ìˆ˜ ìˆìŒ.

####  ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ (íŒŒì´ì¬ìœ¼ë¡œëŠ” ì‹œê°„ì´ˆê³¼, pypyë¡œëŠ” í†µê³¼)

íŒŒì´ì¬ìœ¼ë¡œëŠ” ì‹œê°„ì´ˆê³¼, pypyë¡œëŠ” í†µê³¼í•˜ëŠ”ê²Œ ì •ìƒì¸ê°€?
ì´ê²Œ ì•Œê³ ë¦¬ì¦˜ì˜ ë¬¸ì œì¸ì§€ ì–¸ì–´ ìì²´ì˜ í•œê³„ì¸ì§€ ëª¨ë¥´ë‹ˆê¹Œ ë‹µë‹µí•˜ë„¤...

```python
import heapq


test_cases = int(input())
for test in range(test_cases):
    n, d, c = map(int, input().split())
    graph = [[] for i in range(n+1)]
    for _ in range(d):
        a, b, s = map(int, input().split())
        graph[b].append([s, a])
    # ë‹¤ìµìŠ¤íŠ¸ë¼ ì‹œì‘
    distances = [float("inf") for i in range(n+1)]
    distances[c] = 0
    priority_queue = []
    heapq.heappush(priority_queue, [distances[c], c])
    max_dist = -1
    while priority_queue:
        curr_distance, curr_node = heapq.heappop(priority_queue)
        if distances[curr_node] < curr_distance:
            continue
        for w, adj in graph[curr_node]:
            distance = curr_distance + w
            if distance < distances[adj]:
                distances[adj] = distance
                heapq.heappush(priority_queue, [distance, adj])
    max_dist = 0
    count = 0
    for i in distances:
        if i != float("inf"):
            max_dist = max(i, max_dist)
            count += 1
    print(count, max_dist)
```

#### ë‹µì•ˆ ì½”ë“œ

ë ìš© ì–˜ëŠ” Pythonìœ¼ë¡œë„ ë˜ë„¤...? ë­ê°€ ë‹¤ë¥¸ê±°ì§€? ğŸ˜³

```python
import heapq
import sys
input = sys.stdin.readline


def dijkstra(start):
    q = []
    heapq.heappush(q, (0, start))
    distances[start] = 0
    while q:
        current_dist, current_node = heapq.heappop(q)
        if distances[current_node] < current_dist:
            continue
        for adj_dist, adj_node in adj[current_node]:
            distance = current_dist + adj_dist
            if distances[adj_node] > distance:
                distances[adj_node] = distance
                heapq.heappush(q, (distance, adj_node))


for _ in range(int(input())):
    n, m, start = map(int, input().split())
    adj = [[] for i in range(n+1)]
    for _ in range(m):
        x, y, cost = map(int, input().split())
        adj[y].append((cost, x))
    distances = [1e9] * (n+1)
    dijkstra(start)
    count = 0
    max_distance = 0
    for i in distances:
        if i != 1e9:
            count += 1
            max_distance = max(max_distance, i)
    print(count, max_distance)
```
1. ì¼ë‹¨ `input = sys.stdin.readline` ì€ ë¬´ì¡°ê±´ í•´ì£¼ì. ì´ê²Œ í¬ë¦¬í‹°ì»¬ì¸ ë“¯.
2. iterationì„ ë„ëŠ” ì†ë„ê°€ **íŠœí”Œ**ì´ ë” ë¹ ë¥´ë‹¤ê³  í•œë‹¤. [ë§í¬](https://itholic.github.io/python-list-tuple/)
3. float("inf") ëŒ€ì‹  1e9 ì‚¬ìš©í•´ë„ ë¬´ë°©
4. ë‚˜ë¨¸ì§€ ì½”ë“œëŠ” dijkstraë¥¼ ë¶„ë¦¬í•œ ê±¸ ì œì™¸í•˜ê³ ëŠ” ì°¨ì´ì ì´ ì—†ëŠ”ê²ƒ ê°™ìœ¼ë‹¤.

### Lesson learned

1. listì™€ tupleì˜ ì°¨ì´ì 
   - listëŠ” mutable, tupleì€ immutable
   - iteration ë„ëŠ” ì†ë„ê°€ tupleì´ ë” ë¹ ë¦„

---

## 5719. ê±°ì˜ ìµœë‹¨ ê²½ë¡œ â­ï¸

ë¬¸ì œ ìœ í˜•: `ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ` ë‚œì´ë„: `ì¤‘`

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ 2ë²ˆ ìˆ˜í–‰í•˜ë©´ ë˜ëŠ” ë¬¸ì œ!

1) ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ìˆ˜í–‰
2) ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œì— í¬í•¨ë˜ëŠ” ëª¨ë“  ê°„ì„ ì„  ì¶”ì 
3) ì´ˆê¸° ìµœë‹¨ ê²½ë¡œì— í¬í•¨ëœ ê°„ì„ ì„ **ì œì™¸**í•œ ë’¤ì—, ë‹¤ì‹œ ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰

#### ğŸš« ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ (í‹€ë¦¼)

ë„ˆë¬´ ì–´ë µêµ°. 2ì‹œê°„ ê³ ë¯¼í–ˆëŠ”ë° ëª»í’€ì–´ì„œ í¬ê¸°í–ˆë‹¹.

1. ìµœë‹¨ ê²½ë¡œê°€ ì—¬ëŸ¬ ê°œì¼ ë•ŒëŠ” ì–´ë–»ê²Œ ê·¸ **ëª¨ë“  ìµœë‹¨ ê²½ë¡œë¥¼ ì €ì¥**í•˜ì§€?
2. ìµœë‹¨ ê²½ë¡œë¥¼ **ì œì™¸**í•˜ê³  ìƒê°í•˜ê¸° ìœ„í•´ì„œ ì–´ë–¤ ë°©ë²•ì„ íƒí•´ì•¼ í•˜ì§€? (ë‚œ ë„ì°©ì§€ì ë¶€í„° ì‹œì‘ì§€ì ê¹Œì§€ ìµœë‹¨ê²½ë¡œë¥¼ ë”°ë¼ ê°€ë©´ì„œ í•´ë‹¹ ê°„ì„ ì˜ ê¸¸ì´ë¥¼ 1e9ë¡œ ë§Œë“¤ì–´ì¤¬ìŒ. ê·¸ëŸ°ë° ì´ê±´ ìµœë‹¨ ê²½ë¡œê°€ ì—¬ëŸ¬ê°œì¼ ë•ŒëŠ” í†µí•˜ì§€ ì•ŠëŠ” ë°©ë²•) 

```python
import sys
import heapq
input = sys.stdin.readline

n, m = map(int, input().split())


def dijsktra(start, end):
    q = []
    heapq.heappush(q, (0, s))
    while q:
        curr_dist, curr_node = heapq.heappop(q)
        if dists[curr_node][0] < curr_dist:
            continue
        for adj_dist, adj_node in adj[curr_node]:
            new_dist = curr_dist + adj_dist
            if new_dist < dists[adj_node][0]:
                dists[adj_node] = [new_dist, curr_node]
                heapq.heappush(q, (new_dist, adj_node))
    path = end
    while dists[path][0] != 0:
        optimal_node = dists[path][1]
        print(optimal_node, "opt")
        for i in range(len(adj[optimal_node])):
            if adj[optimal_node][i][1] == path:
                adj[optimal_node][i] = (1e9, adj[optimal_node][i][1])
                isOptimal[optimal_node] = True
                path = dists[path][1]


while n:
    s, d = map(int, input().split())
    adj = [[] for i in range(n)]
    for _ in range(m):
        u, v, p = map(int, input().split())
        adj[u].append((p, v))
    dists = [[1e9, 0]]*n
    dists[s] = [0, s]
    isOptimal = [False]*n
    dijsktra(s, d)
    dists = [[1e9, 0]]*n
    dists[s] = [0, s]
    dijsktra(s, d)
    print(adj)
    print(dists)
    print("\n", dists[d][0] if dists[d][0] != 1e9 else print(-1))
    n, m = map(int, input().split())
# 7 9
# 0 6
# 0 1 1
# 0 2 1
# 0 3 2
# 0 4 3
# 1 5 2
# 2 6 4
# 3 6 2
# 4 6 4
# 5 6 1
# 0 0
```

### ë‹µì•ˆ ì½”ë“œ

#### ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬ì„±í•˜ëŠ” ê°„ì„ ë“¤ì„ ì°¾ëŠ” ë°©ë²•

ê¸°ë³¸ì ì¸ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì€ ì‹œì‘ ì •ì ìœ¼ë¡œë¶€í„°, ëª¨ë“  ì •ì ìœ¼ë¡œì˜ **ìµœë‹¨ ê±°ë¦¬ë§Œì„ ì¶œë ¥**í•´ì¤Œ. ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬ì„±í•˜ëŠ” ê°„ì„ ì„ ì°¾ê¸° ìœ„í•´ì„œëŠ” ë³„ë„ì˜ ë¡œì§ì´ í•„ìš”í•¨.

ì¼ë‹¨ ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ í†µí•´ ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì„ êµ¬í•˜ê³ , **BFS**ë¥¼ í†µí•´ ë„ì°© ì§€ì ìœ¼ë¡œë¶€í„° ì—­ìœ¼ë¡œ ìµœë‹¨ ê²½ë¡œë¥¼ ì¶”ì í•  ìˆ˜ ìˆìŒ.

ë„ì°© ì§€ì ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ê°„ì„ ë“¤ì„ í™•ì¸í•œ í›„, ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”[ë„ì°©ì§€ì ìœ¼ë¡œë“¤ì–´ì˜¤ëŠ”ê°„ì„ ë…¸ë“œ] + ê°„ì„ ê°€ì¤‘ì¹˜ = ìµœë‹¨ê±°ë¦¬ ê°€ ë˜ëŠ” ë…¸ë“œê°€ ë°”ë¡œ ìµœë‹¨ê²½ë¡œë¥¼ êµ¬ì„±í•˜ëŠ” ë…¸ë“œê°€ ë¨.

ì´ë ‡ê²Œ ì—­ì¶”ì ì´ í•„ìš”í•˜ë¯€ë¡œ ê°„ì„ ì…ë ¥ì„ ë°›ìœ¼ë©´ì„œ adj ê·¸ë˜í”„ë¥¼ ë§Œë“¤ ë•Œ ì¶”ê°€ì ìœ¼ë¡œ **reverse_adj** ë„ ë§Œë“¤ì–´ì£¼ì–´ì•¼ í•¨. xì— ê°„ì„ ì„ ë³´ë‚´ëŠ” node,vì˜ ë¦¬ìŠ¤íŠ¸.

#### ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬ì„±í•˜ëŠ” ê°„ì„ ë“¤ì„ ì œì™¸í•˜ëŠ” ë°©ë²•

Dropped ë¼ëŠ” n*n ë°°ì—´ì„ ë§Œë“¤ì–´ë‘ê³  ìœ„ì—ì„œ bfs í•  ë•Œ ( = ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬ì„±í•˜ëŠ” ê°„ì„ ë“¤ì„ ì°¾ì„ë•Œ ) ê°„ì„ [u\][v] ê°€ ì œì™¸ë˜ì—ˆëŠ”ì§€, ì•„ë‹Œì§€ì— ëŒ€í•œ ì •ë³´ë¥¼ ì €ì¥í•¨.

ê·¸ë¦¬ê³  2ë²ˆì§¸ ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ìˆ˜í–‰í•  ë• droppedë¥¼ ì²´í¬í•˜ë©° ì œì™¸ëœ ê°„ì„ ì´ ì•„ë‹ ë•Œì—ë§Œ ê³ ë ¤í•¨.

```python
from collections import deque
import heapq
import sys
input = sys.stdin.readline


def dijkstra():
    q = []
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:
        curr_dist, curr_node = heapq.heappop(q)
        if distance[curr_node] < curr_dist:
            continue
        for adj_node, adj_dist in adj[curr_node]:
            dist = curr_dist + adj_dist
            if distance[adj_node] > dist and not dropped[curr_node][adj_node]:
                distance[adj_node] = dist
                heapq.heappush(q, (dist, adj_node))


def bfs():
    q = deque()
    q.append(end)
    while q:
        now = q.popleft()
        if now == start:
            continue
        for prev, cost in reverse_adj[now]:
            if distance[now] == distance[prev] + cost:
                dropped[prev][now] = True
                q.append(prev)


while True:
    n, m = map(int, input().split())
    if n == 0:
        break
    start, end = map(int, input().split())
    adj = [[] for _ in range(n)]
    reverse_adj = [[] for _ in range(n)]
    for _ in range(m):
        x, y, cost = map(int, input().split())
        adj[x].append((y, cost))
        reverse_adj[y].append((x, cost))
    dropped = [[False]*(n) for _ in range(n)]
    distance = [1e9] * (n+1)
    dijkstra()
    bfs()
    distance = [1e9] * (n+1)
    dijkstra()
    if distance[end] != 1e9:
        print(distance[end])
    else:
        print(-1)
```
#### ìˆ˜ì •í•´ë³¸ ì½”ë“œ

```python
import sys
import heapq
from collections import deque
input = sys.stdin.readline


def dijkstra():
    q = []
    heapq.heappush(q, (0, start))
    while q:
        curr_dist, curr_node = heapq.heappop(q)
        if dists[curr_node] < curr_dist:
            continue
        else:
            for adj_dist, adj_node in adj[curr_node]:
                new_dist = adj_dist + curr_dist
                if new_dist < dists[adj_node] and not dropped[curr_node][adj_node]:
                    dists[adj_node] = new_dist
                    heapq.heappush(q, (new_dist, adj_node))


def bfs():
    path_q = deque()
    path_q.append(end)
    while path_q:
        node = path_q.popleft()
        if node == start:
            # ê°„ì„ ì´ ì…ë ¥ë˜ëŠ” ìˆœì„œëŠ” ëœë¤ì´ë¯€ë¡œ startê°€ popped ë˜ì–´ë„ ë‚˜ë¨¸ì§€ ê°„ì„ ë“¤ì´ ì•„ì§ qì— ë‚¨ì•„ìˆì„ ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ breakë¥¼ í•˜ë©´ ì•ˆë˜ê³  continueë¥¼ í•´ì•¼ í•œë‹¤.
            continue
        for prev_dist, prev_node in reverse_adj[node]:
            if prev_dist + dists[prev_node] == dists[node]:
                dropped[prev_node][node] = True
                path_q.append(prev_node)


while True:
    n, m = map(int, input().split())
    if n == 0:
        break
    start, end = map(int, input().split())
    adj = [[] for i in range(n)]
    reverse_adj = [[] for i in range(n)]
    for _ in range(m):
        u, v, p = map(int, input().split())
        adj[u].append((p, v))
        reverse_adj[v].append((p, u))
    dropped = [[False]*n for i in range(n)]
    dists = [1e9]*n
    dists[start] = 0
    dijkstra()
    bfs()
    dists = [1e9]*n
    dists[start] = 0
    dijkstra()
    print(dists[end] if dists[end] != 1e9 else -1)
```
ì§±ì§± ì–´ë ¤ì›€. êµ¬í˜„ì´ ë³µì¡í•˜ë‹ˆ ì‹¤ìˆ˜ê°€ ì¦ë‹¤. ë‚´ê°€ ì •ì˜í•œ ë°ì´í„° êµ¬ì¡°ì™€ ë³€ìˆ˜ì˜ ìˆœì„œ, ë³€ìˆ˜ëª…ì„ ì´í•´í•˜ê¸° ì‰½ê²Œ ì§“ëŠ” ê²ƒë„ ì¤‘ìš”í•  ê²ƒ ê°™ë‹¤.

---

## 1774. ìš°ì£¼ì‹ ê³¼ì˜ êµê°

ë¬¸ì œ ìœ í˜•: `ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬`, ë‚œì´ë„: `ì¤‘`

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

- ìš°ì£¼ì‹ ì€ ê³§ ì •ì , í†µë¡œëŠ” ê³§ ê°„ì„ . ì¦‰, ëª¨ë“  ì •ì ì´ ì—°ê²°ë˜ë„ë¡ í•˜ê²Œ ë˜ë©´ OK
- 2ì°¨ì› ì¢Œí‘œê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ëª¨ë“  ì¢Œí‘œë¥¼ ì‡ëŠ” ìµœì†Œì‹ ì¥íŠ¸ë¦¬ë¥¼ ë§Œë“¤ë©´ ë¨.
- ì •ì ì˜ ê°œìˆ˜ Nì´ ìµœëŒ€ 1000ì´ë¯€ë¡œ, ê°€ëŠ¥í•œ í†µë¡œì˜ ê°œìˆ˜ëŠ” ì•½ N^2 ë°±ë§Œ ì •ë„, í¬ë£¨ìŠ¤ì¹¼ì€ ê°„ì„ ì˜ ê°œìˆ˜ê°€ Eì¼ ë•Œ **O(ElogE)** ( = ê°„ì„  ì •ë ¬ì— ë“œëŠ” ì‹œê°„ë³µì¡ë„ì™€ ì¼ì¹˜ ) ë¡œ ë™ì‘í•¨
- ë”°ë¼ì„œ ì´ ë¬¸ì œëŠ” í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆìŒ. (ì²œë§Œ ì •ë„)

###  ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ

í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ (Union-find) ì„ ì‚¬ìš©í•´ì„œ í’€ì—ˆìŒ.

ë°©ë²• 1) ~~ì²˜ìŒì—ëŠ” ì—°ê²°ëœ ê°„ì„ ì„ ë¯¸ë¦¬ union ì‹œì¼°ëŠ”ë°, í¬ë£¨ìŠ¤ì¹¼ì€ ê°€ì¤‘ì¹˜(ë¹„ìš©) ê¸°ì¤€ìœ¼ë¡œ sort í•œ ë’¤ ê°€ì¤‘ì¹˜ê°€ ë‚®ì€ ê°„ì„ ë¶€í„° union í•˜ê¸°ì— ì´ë¯¸ union ëœ ê°„ì„ ì„ ê³ ë ¤í•˜ì§€ ì•Šì€ MSTê°€ ë§Œë“¤ì–´ì§„ë‹¤. ë”°ë¼ì„œ X.~~ ì•„ë‹ˆë„¤...? ğŸ˜… ì´ ë°©ë²•ë˜ë„ ë˜ëŠ” ê²ƒ ê°™ë‹¤. ë‚´ê°€ ì²˜ìŒì— make_setì„ í• ë•Œ ì‹¤ìˆ˜í•œ ë“¯. í•˜í•˜ ì´ ë°©ë²•ì´ ì¡°ê¸ˆ ë” ë¹ ë¥´ë‹¤.

ë°©ë²• 2) ê·¸ ë‹¤ìŒì—” ì—°ê²°ëœ ê°„ì„ ì„ connectedì— ë§Œë“¤ì–´ë‘ê³ , ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ë¥¼ êµ¬í•´ì¤„ ë•Œ ì—°ê²°ëœ ê°„ì„ ì¼ ê²½ìš° costë¥¼ 0ìœ¼ë¡œ ì„¤ì •í•´ì£¼ëŠ” ë°©ë²•ì„ íƒí•¨. ì´ ê²½ìš°ë„ ì£¼ì˜í•´ì•¼ í•  ì ì´ ìˆëŠ”ë°, í•œ ì •ì ì—ì„œ ë¯¸ë¦¬ ì—°ê²°ëœ ê°„ì„ ì´ 1ê°œì¼ ê±°ë¼ëŠ” ë³´ì¥ì´ ì—†ìœ¼ë¯€ë¡œ appendë¥¼ í•´ì£¼ì–´ì•¼ í•¨.

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
parent = [0]*(n+1)
rank = [0]*(n+1)
position = [[] for i in range(n+1)]
cost = []
mst = []
connected = [[] for i in range(n+1)]


def make_set(node):
    parent[node] = node
    rank[node] = node


def find(node):
    if parent[node] != node:
        parent[node] = find(parent[node])
    return parent[node]


def union(u, v):
    root1 = find(u)
    root2 = find(v)
    if rank[root1] > rank[root2]:
        parent[root2] = root1
    else:
        parent[root1] = root2
        if rank[root1] == rank[root2]:
            rank[root2] += 1


# ê° ë…¸ë“œì˜ ê°€ì¤‘ì¹˜ êµ¬í•˜ëŠ” í•¨ìˆ˜
def get_cost(a, b):
    return (abs(position[a][0]-position[b][0])**2 + abs(position[a][1]-position[b][1])**2)**0.5


for i in range(n):
    make_set(i+1)

# nê°œì˜ ë…¸ë“œë“¤ì— ëŒ€í•´ ì¢Œí‘œ ì •ë³´ positionì— ì €ì¥
for i in range(n):
    x, y = map(int, input().split())
    position[i+1] = (x, y)

# ì—°ê²°ëœ mê°œì˜ ê°„ì„ ë“¤ì˜ ì •ë³´ ì €ì¥í•˜ê¸°
for j in range(m):
    a, b = map(int, input().split())
    # ì²˜ìŒ ì‹¤ìˆ˜í–ˆë˜ ë¶€ë¶„ - í•œ ì •ì ì— ëŒ€í•´ ì—°ê²°ëœ ì •ì ì´ 1ê°œ ì´ìƒì¼ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ connected[a] = bê°€ ì•„ë‹ˆë¼ appendë¥¼ í•´ì¤˜ì•¼ í•œë‹¤.
    connected[a].append(b)
    connected[b].append(a)

# ê°„ì„ ë“¤ì˜ ëª¨ë“  ê°€ì¤‘ì¹˜ êµ¬í•˜ê¸°. ì—°ê²°ëœ ê°„ì„ ì´ë©´ costë¥¼ 0ìœ¼ë¡œ í•´ì£¼ê¸°
for i in range(1, n):
    for j in range(i+1, n+1):
        if j in connected[i]:
            cost.append((0, i, j))
        else:
            cost.append((get_cost(i, j), i, j))

cost.sort()

for edge in cost:
    weight, u, v = edge
    if find(u) != find(v):
        union(u, v)
        mst.append(edge)

total_cost = 0
for edges in mst:
    total_cost += edges[0]

print(format(total_cost, ".2f"))
```

### ë‹µì•ˆ ì½”ë“œ

í•´ì„¤ì´ë‘ ì¢€ ë‹¤ë¥´ë„¤... í 
unionì„ í•´ì¤˜ë„ ëœë‹¨ ë§ì¸ê°€...!

```python
import math
import sys
input = sys.stdin.readline

def get_distance(p1,p2):
  a = p1[0] - p2[0]
  b = p1[1] - p2[1]
  return math.sqrt((a*a) + (b*b))

# path compressionìœ¼ë¡œ ìµœìƒìœ„ ë¶€ëª¨ë¥¼ ë¶€ëª¨ë¡œ ë§Œë“¤ì–´ì£¼ë©´ì„œ ì°¾ì•„ì£¼ê¸°
def get_parent(parent, n):
  if parent(n) == n:
    return n
 	return get_parent(parent, parent[n])

# a,bë¥¼ í•©ì³ì£¼ê¸°
def union_parent(parent, a, b):
  a = get_parent(parent, a)
  b = get_parent(parent, b)
  if a < b:
    parent[b] = a
  else:
    parnet[a] = b

# aì™€ bê°€ ê°™ì€ ë¶€ëª¨ë¼ë©´ True, ë‹¤ë¥¸ ë¶€ëª¨ë¼ë©´ False
def find_parent(parent, a, b):
  a = get_parent(parent, a)
  b = get_parent(parent, b)
  if a == b:
    return True
 	else:
    return False
  
edges = []
parent = []
locations = []
n,m = map(int, input().split())

for _ in range(n):
  x,y = map(int, input().split())
  locations.append((x,y))
  
length = len(locations)

# ëª¨ë“  ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ êµ¬í•˜ê¸°
for i in range(length -1):
  for j in range(i+1, length):
    edges.append((i+1, j+1, get_distance(locations[i], locations[j])))

# parent ìê¸° ìì‹ ìœ¼ë¡œ ì„¤ì •í•´ì£¼ê¸°
for i in range(1, n+1):
  parent[i] = i
 
# ì´ë¯¸ ì—°ê²°ëœ ê°„ì„ ì— ëŒ€í•´ 
for i in range(m):
  a,b = map(int, input().split())
  union_parent(parent, a, b)

# ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
edges.sort(key=lambda data: data[2])

result = 0
for a,b,cost in edges:
  # a,bê°€ ì´ë¯¸ ì—°ê²°ëœê²Œ ì•„ë‹ˆë¼ë©´
  if not find_parent(parent, a, b)ë©´
    union_parent(parent, a, b)
    result += cost
    
print("%0.2f" % result)
```

### ìˆ˜ì •í•´ë³¸ ì½”ë“œ

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
parent = [0]*(n+1)
rank = [0]*(n+1)
position = [[] for i in range(n+1)]
cost = []
mst = []


def make_set(node):
    parent[node] = node
    rank[node] = 0


def find(node):
    if parent[node] != node:
        parent[node] = find(parent[node])
    return parent[node]


def union(u, v):
    root1 = find(u)
    root2 = find(v)
    if rank[root1] > rank[root2]:
        parent[root2] = root1
    else:
        parent[root1] = root2
        if rank[root1] == rank[root2]:
            rank[root2] += 1


# ê° ë…¸ë“œì˜ ê°€ì¤‘ì¹˜ êµ¬í•˜ëŠ” í•¨ìˆ˜
def get_cost(a, b):
    return (abs(position[a][0]-position[b][0])**2 + abs(position[a][1]-position[b][1])**2)**0.5


for i in range(n):
    make_set(i+1)

# nê°œì˜ ë…¸ë“œë“¤ì— ëŒ€í•´ ì¢Œí‘œ ì •ë³´ positionì— ì €ì¥
for i in range(n):
    x, y = map(int, input().split())
    position[i+1] = (x, y)

# ê°„ì„ ë“¤ì˜ ëª¨ë“  ê°€ì¤‘ì¹˜ êµ¬í•˜ê¸°
for i in range(1, n):
    for j in range(i+1, n+1):
        cost.append((get_cost(i, j), i, j))


# ì—°ê²°ëœ mê°œì˜ ê°„ì„ ë“¤ì— ëŒ€í•´ union
for j in range(m):
    a, b = map(int, input().split())
    union(a, b)

cost.sort()

for edge in cost:
    weight, u, v = edge
    if find(u) != find(v):
        union(u, v)
        mst.append(edge)

total_cost = 0
for edges in mst:
    total_cost += edges[0]

print(format(total_cost, ".2f"))
```

### Lesson learned

#### ì†Œìˆ˜ì  í˜•ì‹ ì¶œë ¥

ë°˜ì˜¬ë¦¼ì´ë‚˜, ì˜¬ë¦¼ ë§ê³  ë”± ê¹”ë”í•˜ê²Œ ì†Œìˆ˜ì  ì•„ë˜ ëª‡ ìë¦¬ìˆ˜ê¹Œì§€ ì˜ë¼ì„œ ì¶œë ¥í•˜ëŠ” ë°©ë²•ì€ ì•„ë˜ì™€ ê°™ã„·.

`print("%0.2f" % result)`

#### MST ë³µìŠµ

ìµœì†Œì‹ ì¥íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ì€ **(1) Kruskal, (2) Prim** ì´ë ‡ê²Œ 2ê°€ì§€ê°€ ìˆë‹¤.

#### í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ë³µìŠµ

í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì€ **íƒìš• ì•Œê³ ë¦¬ì¦˜**ì„ ê¸°ì´ˆë¡œ í•˜ë©°, **Union-Find**ë¥¼ ì‚¬ìš©í•œë‹¤.

**[ë™ì‘ ë°©ì‹]**

1. ëª¨ë“  ì •ì ì„ ë…ë¦½ì ì¸ ì§‘í•©ìœ¼ë¡œ ë‚˜ëˆ„ê³  (make_set)
2. ëª¨ë“  ê°„ì„ ì„ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•œ ë’¤ ë¹„ìš©ì´ ì‘ì€ ê°„ì„ ë¶€í„° ì–‘ ëì˜ ë‘ ì •ì ì„ ë¹„êµí•œë‹¤
3. ì–‘ ëì˜ ë‘ ì •ì ì˜ ìµœìƒìœ„ ì •ì ì„ í™•ì¸ (ì‚¬ì´í´ ë°©ì§€) í•˜ê³ , ì„œë¡œ ë‹¤ë¥¼ ê²½ìš° ë‘ ì •ì ì„ ì—°ê²°í•œë‹¤.

Union-by-rank ì™€ path compression ê¸°ë²•ì„ ì‚¬ìš©í•˜ë©´ union/find ì—°ì‚°ì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(logN), ì „ì²´ ì‹œê°„ ë³µì¡ë„ëŠ” O(MlogN) ìœ¼ë¡œ ë‚®ì¶œ ìˆ˜ ìˆë‹¤.

í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ìœ„í•´ì„  **ë…¸ë“œë³„ë¡œ parentì™€ rankë¥¼ ì €ì¥**í•´ì•¼ í•œë‹¤.
(1) make_set (2) find (3) union ë¡œì§ì´ í•„ìš”í•œ

```python
parent = []
rank = []

def make_set(node):
  parent[node] = node
  rank[node] = 0
  
def find(node):
  if parent[node] != node:
    parent[node] = find(parent[node])
  return parent[node]

def union(v,u):
  # root ë…¸ë“œë¥¼ í™•ì¸í•œ ë’¤
  root1 = find(v)
  root2 = find(u)
  # í•©ì³ì£¼ê¸°
  if rank[root1] > rank[root2]:
    parnet[root2] = root1
  else:
    parent[root1] = root2
    if rank[root1] == rank[root2]:
      rank[root2] +=1
        
def kruskal(graph):
  mst = list()
  # 1. ì´ˆê¸°í™”
  for node in graph['vertices']:
    make_set(node) # parent, rank ì´ˆê¸°í™”
  edges = graph['edges']
  # 2. ê°„ì„  ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
  edges.sort()
  # 3. ì‚¬ì´í´ ì—†ë‹¤ë©´ ê°„ì„  ì—°ê²°
  for edge in edges:
    weight, node_v, node_u = edge
    if find(node_v) != find(node_u):
      union(node_v, node_u)
      mst.append(edge)
  return mst
```

í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” O(E log E)

1) ì´ˆê¸°í™” (make_set) ê³¼ì • : ë…¸ë“œì˜ ê°¯ìˆ˜ ë§Œí¼ loopë¥¼ í•œë²ˆ ë„ë‹ˆê¹Œ O(V)
2) ê°„ì„  ì •ë ¬ ê³¼ì • : í€µì†ŒíŠ¸ ì‚¬ìš©í•œë‹¤ë©´ ê°„ì„  ê°¯ìˆ˜ë¥¼ Eë¼ê³  í•  ë•Œ O(E log E)
3) union-find ê³¼ì • : ê°„ì„ ë“¤ì„ í•˜ë‚˜ì”© ëŒë©° union-find (O(1)) ë§Œí¼ì˜ ì‘ì—…ì„ ì§„í–‰í•˜ë¯€ë¡œ O(E)

ì„¸ ì‘ì—… ì¤‘ ê°€ì¥ ì‹œê°„ë³µì¡ë„ê°€ ë†’ì€ ê³¼ì •ì€ ê°„ì„  ì •ë ¬ ê³¼ì •. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì€ ë”°ë¼ì„œ O(E log E) ë§Œí¼ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§„ë‹¤.

#### í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ ë³µìŠµ

í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ ì—­ì‹œ íƒìš• ì•Œê³ ë¦¬ì¦˜ì„ ê¸°ì´ˆë¡œ í•œë‹¤. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ê³¼ì˜ ì°¨ì´ì ì€?
í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì´ **ì „ì²´ ê°„ì„ ë“¤ ì¤‘ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ë¶€í„° ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šê²Œ ì„ íƒ**í•œë‹¤ë©´, í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ **íŠ¹ì • ì •ì ì—ì„œ ì‹œì‘**í•´ í•´ë‹¹ ì •ì ì— ì—°ê²°ëœ ê°„ì„ ë“¤ ì¤‘ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ì„ ì„ íƒí•´ê°€ë©° MSTë¥¼ êµ¬í•œë‹¤.

**[ë™ì‘ ë°©ì‹]**

1. ì„ì˜ì˜ ì •ì ì„ ì„ íƒí•´ **ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©**ì— ì‚½ì…
2. ì„ íƒëœ ì •ì ì— ì—°ê²°ëœ ê°„ì„ ë“¤ì„ ê°„ì„  ë¦¬ìŠ¤íŠ¸ì— ì‚½ì…
3. ê°„ì„  ë¦¬ìŠ¤íŠ¸ì—ì„œ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” ê°„ì„ ë¶€í„° ì¶”ì¶œ (pop) í•˜ì—¬
   1. í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì •ì ì´ "ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©" ì— ì´ë¯¸ ë“¤ì–´ ìˆë‹¤ë©´ ìŠ¤í‚µ
   2. í•´ë‹¹ ê°„ì„ ì— ì—°ê²°ëœ ì •ì ì´ "ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©" ì— ë“¤ì–´ìˆì§€ ì•Šë‹¤ë©´ í•´ë‹¹ ê°„ì„ ì„ ì„ íƒí•˜ê³ , í•´ë‹¹ ê°„ì„  ì •ë³´ë¥¼ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— ì‚½ì…
4. ê°„ì„  ë¦¬ìŠ¤íŠ¸ì— ë” ì´ìƒì˜ ê°„ì„ ì´ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µ

```python
# ê°„ì„ ë§Œ í‘œí˜„. ë…¸ë“œëŠ” ë³„ë„ë¡œ í‘œí˜„í•  í•„ìš” ì—†ìŒ.
from collections import defaultdict
from heapq import *

# ê°„ì„  ì €ì¥ ì˜ˆì‹œ
myedges = [
    (7, 'A', 'B'), (5, 'A', 'D'), (8, 'B', 'C'), (9, 'B', 'D'), (7, 'B', 'E'),
    (5, 'C', 'E'),
    (7, 'D', 'E'), (6, 'D', 'F'),
    (8, 'E', 'F'), (9, 'E', 'G'),
    (11, 'F', 'G')
]

def prim(start_node, edges):
  adjacent_edges = defaultdict(list)
  mst = list()
  for weight, n1, n2 in edges:
    # ëª¨ë“  ê°„ì„ ë“¤ì— ëŒ€í•´ ì¸ì ‘ ì •ì  ì •ë³´ë¥¼ adjacent_edgesì— ì €ì¥
    adjacent_edges[n1].append((weight, n1, n2))
    adjacent_edges[n2].append((weight, n2, n1))
  
  # ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©ì— start nodeë¥¼ ë„£ì–´ì£¼ê¸°
  connected_nodes = set(start_node)
  # start nodeì˜ ì¸ì ‘ ê°„ì„ ë“¤ì„ í›„ë³´ ë¦¬ìŠ¤íŠ¸ì— ë„£ì–´ì£¼ê¸°
  candidate_edge_list = adjacent_edges[start_node]
  # í›„ë³´ ë¦¬ìŠ¤íŠ¸ë¥¼ minHeap êµ¬ì¡°ë¡œ ë§Œë“¤ê¸° - ìµœì†Œ ê°€ì¤‘ì¹˜ì˜ ì •ì ë¶€í„° ì„ íƒë˜ê²Œ ë¨
  heqpify(candidate_edge_list)

  # í›„ë³´ ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì§€ ì•Šì•˜ë‹¤ë©´
  while candidate_edge_list:
    # êº¼ë‚´ì„œ
    weight, n1, n2 = heappop(candidate_edge_list)
    # í•´ë‹¹ ê°„ì„  (ì‹œì‘ì  n1)ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì (n2)ì´ ì´ë¯¸ ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©ì— ì—†ë‹¤ë©´
    if n2 not in connected_nodes:
      # ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©ì— ë„£ì–´ì£¼ê³ 
      connected_nodes.add(n2)
      # mst ì— ì¶”ê°€í•´ì£¼ê¸°
      mst.append((weight, n1, n2))
      # mstì— ì¶”ê°€ëœ ì •ì ì— ì—°ê²°ëœ ê°„ì„ ë“¤ì— ëŒ€í•´
      for edge in adjacent_edges[n2]:
        # í•´ë‹¹ ê°„ì„  (ì‹œì‘ì  n1)ì— ì—°ê²°ëœ ì¸ì ‘ ì •ì (n2)ì´ ì´ë¯¸ ì—°ê²°ëœ ë…¸ë“œ ì§‘í•©ì— ì—†ë‹¤ë©´
        if edge[2] not in connected_nodes:
          # start nodeì˜ ì¸ì ‘ ê°„ì„ ë“¤ì„ í›„ë³´ ë¦¬ìŠ¤íŠ¸ (minHeap êµ¬ì¡°)ì— ë„£ì–´ì£¼ê³  ë°˜ë³µ
          heappush(candidate_edge_lsit, edge)
  return mst

print(prim('A', myedges))

```
