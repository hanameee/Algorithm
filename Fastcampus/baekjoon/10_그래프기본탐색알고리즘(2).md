# 10. ê·¸ë˜í”„ ê¸°ë³¸ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ (2)


## 2606. ë°”ì´ëŸ¬ìŠ¤

ë¬¸ì œ ìœ í˜•: `DFS, BFS`, ë‚œì´ë„: `í•˜`

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

- ë‹¨ìˆœíˆ íŠ¹ì •í•œ ë…¸ë“œë¡œë¶€í„° ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ì •ì ì˜ ê°¯ìˆ˜ë¥¼ ì¶œë ¥í•˜ë©´ ë¨
- ì»´í“¨í„°ì˜ ìˆ˜ê°€ ì ìœ¼ë¯€ë¡œ (100ê°œ ì´í•˜), DFSë¥¼ ì´ìš©í•´ ë¹ ë¥´ê²Œ ë¬¸ì œë¥¼ í‘¸ëŠ” ê²ƒì´ ìœ ë¦¬ (?) ì¬ê·€í•¨ìˆ˜ ì‚¬ìš©í•  ê²½ìš°... :)

####  ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ (DFS ì‚¬ìš©)

```python
import sys

n = int(sys.stdin.readline().strip())
e = int(sys.stdin.readline().strip())

adj = [[] for i in range(n+1)]
for i in range(e):
    x, y = map(int, sys.stdin.readline().split())
    adj[x].append(y)
    adj[y].append(x)


def dfs(start_node):
    visited = [0 for i in range(n+1)]
    stack = [start_node]
    while stack:
        current_node = stack.pop()
        for adj_node in adj[current_node]:
            if not visited[adj_node]:
                stack.append(adj_node)
                visited[adj_node] = 1
    result = 0
    for i in visited[2:]:
        if i:
            result += 1
    return result


print(dfs(1))
```

#### ë‹µì•ˆ ì½”ë“œ

ì¬ê·€ ì‚¬ìš©í•´ì„œ DFS.
ê·¸ëƒ¥ ë°©ë¬¸ í•  ë•Œë§ˆë‹¤ ê°¯ìˆ˜ ì„¸ì£¼ë©´ ë¨.

```python
n = int(input())
m = int(input())
adj = [[] for _ in range(n+1)]
visited = [False] * (n+1)
count = 0

for _ in range(m):
  x, y = map(int, input().split())
  adj[x].append(y)
  adj[y].append(x)

def dfs(now_pos):
  global count
  count += 1
  visited[now_pos] = True
  for next_pos in adj[now_pos]:
    if not visited[next_pos]:
      dfs(next_pos)

dfs(1)
print(count-1) # ì²«ë²ˆì§¸ ì •ì ì€ ë¹¼ì¤˜ì•¼ í•˜ë‹ˆê¹
```
#### ë‹µì•ˆ ë³´ê³  2ì°¨ë¡œ ìˆ˜ì •í•œ ì½”ë“œ

visitedë¥¼ ë¹ˆ ë°°ì—´ë¡œ ê´€ë¦¬í•˜ëŠ” ê²ƒë³´ë‹¤, node ë§Œí¼ì˜ ë°°ì—´ë¡œ ë¯¸ë¦¬ ì¡ì•„ë‘ê³  T/Fë¡œ ì²´í¬í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤!

```python
import sys
from collections import deque


n, m, v = map(int, sys.stdin.readline().split())
graph = [[] for i in range(n+1)]

for i in range(m):
    node_a, node_b = map(int, sys.stdin.readline().split())
    graph[node_a].append(node_b)
    graph[node_b].append(node_a)

adj_queue = deque([])
adj_stack = []
visited = [False for _ in range(n+1)]


def dfs(start_node):
    visited[start_node] = True
    print(start_node, end=' ')
    adj = sorted(graph[start_node], reverse=True)
    adj_stack.extend(adj)
    while adj_stack:
        node = adj_stack.pop()
        if visited[node] == False:
            visited[node] = True
            print(node, end=' ')
            adj = sorted(graph[node], reverse=True)
            adj_stack.extend(adj)
    return


def bfs(start_node):
    visited[start_node] = True
    print(start_node, end=' ')
    adj = sorted(graph[start_node])
    adj_queue.extend(adj)
    while adj_queue:
        node = adj_queue.popleft()
        if visited[node] == False:
            visited[node] = True
            print(node, end=' ')
            adj = sorted(graph[node])
            adj_queue.extend(adj)
    return


dfs(v)
print()

visited = [False for _ in range(n+1)]

bfs(v)

```
---

## 1012. ìœ ê¸°ë† ë°°ì¶” â­ï¸

ë¬¸ì œ ìœ í˜•: `DFS, BFS` ë‚œì´ë„: `í•˜`

- DFS, BFS ì‘ìš© ë¬¸ì œ ì¤‘ ì¶œì œ ë¹„ì¤‘ì´ ë§¤ìš° ë†’ì€ ìœ í˜•
- DFSë¡œ ë¬¸ì œë¥¼ í‘¸ëŠ” ê²½ìš°, sys ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ setrecursionlimit() í•¨ìˆ˜ ì„¤ì •ì„ í•´ì¤˜ì•¼ í•¨

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

1) **ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜**ë¥¼ ì„¸ëŠ” ë¬¸ì œ
2) **ëª¨ë“  ì •ì ì— ëŒ€í•˜ì—¬ DFS ë° BFS ë¥¼ ìˆ˜í–‰**í•˜ê³ , í•œë²ˆ ë°©ë¬¸í•œ ì •ì ì€ ë‹¤ì‹œ í™•ì¸í•˜ì§€ ì•ŠìŒ
3) ì „ì²´ì ìœ¼ë¡œ DFS ë° BFSë¥¼ ìˆ˜í–‰í•œ ì´ íšŸìˆ˜ë¥¼ ê³„ì‚°

#### ğŸš« ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ (í‹€ë¦¼)

ë°˜ë¡€ë¥¼ ëª»ì°¾ì•˜ë‹¤

```python
from collections import deque

t = int(input())
for test_case in range(t):
    m, n, k = map(int, input().split())
    visited = [[0]*n for i in range(m)]
    q = deque([])
    plants = [[] for i in range(k)]
    worm = 1
    for i in range(k):
        x, y = map(int, input().split())
        plants[i] = [x, y]
    q.append(plants[0])
    while len(q) > 0:
        plant = q.popleft()
        x, y = plant
        visited[x][y] = 1
        plant_adj = []
        if x < m-1:
            plant_adj.append([x+1, y])
        if 0 < x:
            plant_adj.append([x-1, y])
        if y < n-1:
            plant_adj.append([x, y+1])
        if 0 < y:
            plant_adj.append([x, y-1])
        for plant in plants:
            x, y = plant
            if not visited[x][y]:
                if plant in plant_adj:
                    q.append(plant)
                    break
        if len(q) == 0:
            for plant in plants:
                x, y = plant
                if not visited[x][y]:
                    q.append(plant)
                    worm += 1
                    break
    print(worm)
```

ìœ„ ì½”ë“œì˜ ë°˜ë¡€

```
1 
3 2 5
0 0
0 1 
1 0
2 0
2 1
```

ë‹µì€ 1ì´ì–´ì•¼ í•˜ëŠ”ë°, ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œë¡œëŠ” 2ê°€ ë‚˜ì˜´.

####  âœ… ìˆ˜ì •í•œ ì½”ë“œ

ê²Œì‹œíŒ ë’¤ì ¸ë³´ë‹¤ê°€ ì‹¤ìˆ˜í•œ ë¶€ë¶„ì„ ì°¾ì•˜ë‹¤.
ë‚˜ëŠ” ìƒí•˜ì¢Œìš°ë¡œ íƒìƒ‰í•˜ë‹¤ê°€ ë°°ì¶”ê°€ ì‹¬ì–´ì§„ ê³³ì„ ì°¾ìœ¼ë©´ ë‹¤ì‹œ ê·¸ ì§€ì ì„ ê¸°ì ìœ¼ë¡œ ìƒí•˜ì¢Œìš° íƒìƒ‰í•¨.

í•˜ì§€ë§Œ, plant_adj ëŠ” í•˜ë‚˜ì˜ ì—°ê²°ëœ ë°°ì¶”ë°­ì—ì„œëŠ” ê³„ì† ëˆ„ì ë˜ì–´ì•¼ í•¨.

```python
from collections import deque

t = int(input())
for test_case in range(t):
    m, n, k = map(int, input().split())
    visited = [[0]*n for i in range(m)]
    q = deque([])
    plants = [[] for i in range(k)]
    worm = 1
    for i in range(k):
        x, y = map(int, input().split())
        plants[i] = [x, y]
    q.append(plants[0])
    plant_adj = []
    while len(q) > 0:
        plant = q.popleft()
        x, y = plant
        visited[x][y] = 1
        if x < m-1:
            plant_adj.append([x+1, y])
        if 0 < x:
            plant_adj.append([x-1, y])
        if y < n-1:
            plant_adj.append([x, y+1])
        if 0 < y:
            plant_adj.append([x, y-1])
        for plant in plants:
            x, y = plant
            if not visited[x][y]:
                if plant in plant_adj:
                    q.append(plant)
                    break
        if len(q) == 0:
            for plant in plants:
                x, y = plant
                if not visited[x][y]:
                    q.append(plant)
                    worm += 1
                    plant_adj = []
                    break
    print(worm)
```

ë­”ê°€ ë³µì¡í•˜ê²Œ í‘¼ ê²ƒ ê°™ìœ¼ë‹¤.
ë‚´ê°€ í‘¼ ë°©ì‹ì„ ì •ë¦¬í•˜ë©´, ì¼ë‹¨ plantsì— ë°°ì¶”ì˜ [x,y] ë°ì´í„°ë¥¼ ë‹¤ ì €ì¥, visitedì— ë°©ë¬¸ ì—¬ë¶€ ì €ì¥
qì— ë‹¤ìŒì— íƒìƒ‰í•  plant ë¥¼ ë„£ì–´ë‘ 

ì²«ë²ˆì§¸ plant ë¥¼ qì— ë„£ê³ , popí•˜ë©´ì„œ visitedì— ì²´í¬.
popped ëœ ë°°ì¶”ì˜ (ë²”ìœ„ì— ë§ëŠ”) ìƒí•˜ì¢Œìš° ë°­ ìœ„ì¹˜ë¥¼ plant_adjì— ì¶”ê°€.
ë°°ì¶”ëª©ë¡ plantsì— ëŒ€í•´ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ëŠ”ë° plant_adjì— ìˆë‹¤ë©´ qì— ì¶”ê°€í•˜ê³  break
plant_adj ì¤‘ plantsì— ì¼ì¹˜í•˜ëŠ” ê³³ì´ ì—†ë‹¤ë©´ ë‚¨ì€ plantsì— ëŒ€í•´ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì• ë¥¼ qì— ì¶”ê°€í•˜ê³  ì§€ë ì´ í•œë§ˆë¦¬ ì¶”ê°€í•˜ê³  plant_adj ì´ˆê¸°í™”

#### ë‹µì•ˆ ì½”ë“œ

```python
import sys
sys.setrecursionlimit(100000)

def dfs(x, y):
  visited[x][y] = True
  directions = [(-1,0), (1,0), (0,-1), (0,1)]
  for dx, dy in directions: # ìƒí•˜ì¢Œìš°ë¥¼ ë‹¤ ì‹œë„í•´ë´„
    nx, ny = x+dx, y+dy
    if nx < 0 or nx >= n or ny < 0 or ny >= m: # ì¡°ê±´ ì²´í¬
      continue
    if array[nx][ny] and not visited[nx][ny]: # ë°°ì¶”ê°€ ì‹¬ì–´ì ¸ ìˆëŠ”ë° ë°©ë¬¸ ì•ˆí–ˆë‹¤ë©´
      dfs(nx, ny)

for _ in range(int(input())):
  m,n,k = map(int, input().split())
  array = [[0]*m for _ in range(n)]
  visited = [[False]*m for _ in range(n)]
  for _ in range(k):
    y, x = map(int, input().split())
    array[x][y] = 1 # ë°°ì¶”ê°€ ì‹¬ì–´ì ¸ ìˆëŠ” ê³³ì„ ì…ë ¥ë°›ì•„ arrayì— í‘œì‹œ
  result = 0
  # ëª¨ë“  ì •ì ë“¤ì„ ë‹¤ íƒìƒ‰
  for i in range(n):
    for j in range(m):
      # ë°°ì¶”ê°€ ì‹¬ì–´ì ¸ ìˆëŠ”ë° ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
      if array[i][j] and not visited[i][j]:
        dfs(i,j)
        result += 1
  print(result)
  
```
#### ìˆ˜ì •í•´ë³¸ ì½”ë“œ

ë‚˜ëŠ” ë­”ê°€ ì‹ ê¸°í•˜ê²Œ í’€ì—ˆë˜ ê²ƒì´ë‹¤...ë”±íˆ BFSì™€ DFSë¥¼ í™œìš©í•œ ê²ƒ ê°™ì§€ê°€ ì•Šìœ¼ë‹¤...
BFS ë°©ì‹ìœ¼ë¡œ ë‹¤ì‹œ í•´ë³´ì!

```python
from collections import deque

t = int(input())


def bfs(plant):
    global worm
    worm += 1
    q = deque()
    q.append(plant)
    while q:
        x, y = q.popleft()
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for dx, dy in directions:
            nx = x+dx
            ny = y+dy
            if 0 <= nx < m and 0 <= ny < n:
                if plants[nx][ny] and not visited[nx][ny]:
                    q.append([nx, ny])
                    visited[nx][ny] = 1
    return


for test_case in range(t):
    m, n, k = map(int, input().split())
    visited = [[0]*n for i in range(m)]
    q = deque([])
    plants = [[0]*n for i in range(m)]
    worm = 0
    for i in range(k):
        x, y = map(int, input().split())
        visited[x][y] = 0
        plants[x][y] = 1

    for i in range(m):
        for j in range(n):
            if plants[i][j] and not visited[i][j]:
                visited[i][j] = 1
                bfs([i, j])

    print(worm)
```
ìì˜ìì˜í•œ ì‹¤ìˆ˜ê°€ ì¦êµ°. í—ˆí—ˆí—ˆ. ì—¬ëŸ¬ë²ˆ í’€ì–´ë³´ì
ë¬´íŠ¼ ì´ë ‡ê²Œ bfsë¥¼ í™œìš©í•˜ë©´ í›¨ì”¬ ê¹”ë”í•˜ê³  ë¹¨ë¦¬ í’€ ìˆ˜ ìˆë‹¤. plants ì—­ì‹œ visitedì™€ ë§ˆì°¬ê°€ì§€ë¡œ 2ì°¨ì› ë°°ì—´ë¡œ ì „ë¶€ ë‹¤ ë§Œë“¤ê³  0/1 ë¡œ check!

### Lesson learned

#### BFS ì—ì„œëŠ” ì›ì†Œë¥¼ íì— ë„£ì„ ë•Œ ë°©ë¬¸í‘œì‹œë¥¼ í•´ì•¼ í•œë‹¤

ê·¸ ë™ì•ˆ ì™œ íì—ì„œ pop í•  ë•Œê°€ ì•„ë‹ˆë¼, íì— ë„£ì„ë•Œ ë°©ë¬¸ í‘œì‹œë¥¼ í•´ì•¼ í•˜ëŠ”ì§€ ê¶ê¸ˆí–ˆëŠ”ë° ì´ë²ˆ ë¬¸ì œ í’€ë‹¤ê°€ ì‹œê°„ì´ˆê³¼ ë‚˜ë³´ê³  ê²Œì‹œíŒì„ ì°¾ì•„ë³¸ ë’¤ì— ê·¸ ì´ìœ ë¥¼ ì•Œì•˜ë‹¤. BFSì—ì„œëŠ” **íì— ì›ì†Œë¥¼ ë„£ì„ ë•Œ ë°©ë¬¸ í‘œì‹œ**ë¥¼ í•´ì•¼ ì¤‘ë³µ ë°©ë¬¸ì´ ì¼ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤.

ì™œëƒ?

1 1
1 1

ìœ„ì™€ ê°™ì€ ìƒíƒœì—ì„œ ì™¼ìª½ ìœ„ì—ì„œ ì‹œì‘í•˜ë©´, ê·¸ ë‹¤ìŒ ì˜¤ë¥¸ìª½ ìœ„ì™€ ì™¼ìª½ ì•„ë˜ë¥¼ ê°ê° ë°©ë¬¸í•˜ëŠ”ë° ì´ ë‘˜ì´ì„œ ì˜¤ë¥¸ìª½ ì•„ë˜ë¥¼ ê°ê° íì— ë„£ëŠ” ë™ì•ˆ ë§‰ì•„ì„¸ìš°ëŠ” ì¥ì¹˜ê°€ ì—†ê¸° ë•Œë¬¸ì—! ()

ë”°ë¼ì„œ ë°˜ë“œì‹œ íì— ì›ì†Œë¥¼ ë„£ì„ ë•Œ ë°©ë¬¸ í‘œì‹œë¥¼ í•´ì•¼ í•œë‹¤.

---

## 1325. íš¨ìœ¨ì ì¸ í•´í‚¹

ë¬¸ì œ ìœ í˜•: `DFS, BFS`, ë‚œì´ë„: `í•˜`

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

- ë‹¨ìˆœíˆ íŠ¹ì •í•œ ë…¸ë“œë¡œë¶€í„° ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ì •ì ì˜ ê°¯ìˆ˜ë¥¼ ì¶œë ¥í•˜ë©´ ë¨
- ì»´í“¨í„°ì˜ ìˆ˜ê°€ ì ìœ¼ë¯€ë¡œ (100ê°œ ì´í•˜), DFSë¥¼ ì´ìš©í•´ ë¹ ë¥´ê²Œ ë¬¸ì œë¥¼ í‘¸ëŠ” ê²ƒì´ ìœ ë¦¬ (?) ì¬ê·€í•¨ìˆ˜ ì‚¬ìš©í•  ê²½ìš°... :)

####  ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ (DFS ì‚¬ìš©)

```python
import sys

n = int(sys.stdin.readline().strip())
e = int(sys.stdin.readline().strip())

adj = [[] for i in range(n+1)]
for i in range(e):
    x, y = map(int, sys.stdin.readline().split())
    adj[x].append(y)
    adj[y].append(x)


def dfs(start_node):
    visited = [0 for i in range(n+1)]
    stack = [start_node]
    while stack:
        current_node = stack.pop()
        for adj_node in adj[current_node]:
            if not visited[adj_node]:
                stack.append(adj_node)
                visited[adj_node] = 1
    result = 0
    for i in visited[2:]:
        if i:
            result += 1
    return result


print(dfs(1))
```

#### ë‹µì•ˆ ì½”ë“œ

ì¬ê·€ ì‚¬ìš©í•´ì„œ DFS.
ê·¸ëƒ¥ ë°©ë¬¸ í•  ë•Œë§ˆë‹¤ ê°¯ìˆ˜ ì„¸ì£¼ë©´ ë¨.

```python
n = int(input())
m = int(input())
adj = [[] for _ in range(n+1)]
visited = [False] * (n+1)
count = 0

for _ in range(m):
  x, y = map(int, input().split())
  adj[x].append(y)
  adj[y].append(x)

def dfs(now_pos):
  global count
  count += 1
  visited[now_pos] = True
  for next_pos in adj[now_pos]:
    if not visited[next_pos]:
      dfs(next_pos)

dfs(1)
print(count-1) # ì²«ë²ˆì§¸ ì •ì ì€ ë¹¼ì¤˜ì•¼ í•˜ë‹ˆê¹
```

#### ë‹µì•ˆ ë³´ê³  2ì°¨ë¡œ ìˆ˜ì •í•œ ì½”ë“œ

visitedë¥¼ ë¹ˆ ë°°ì—´ë¡œ ê´€ë¦¬í•˜ëŠ” ê²ƒë³´ë‹¤, node ë§Œí¼ì˜ ë°°ì—´ë¡œ ë¯¸ë¦¬ ì¡ì•„ë‘ê³  T/Fë¡œ ì²´í¬í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤!

```python
import sys
from collections import deque


n, m, v = map(int, sys.stdin.readline().split())
graph = [[] for i in range(n+1)]

for i in range(m):
    node_a, node_b = map(int, sys.stdin.readline().split())
    graph[node_a].append(node_b)
    graph[node_b].append(node_a)

adj_queue = deque([])
adj_stack = []
visited = [False for _ in range(n+1)]


def dfs(start_node):
    visited[start_node] = True
    print(start_node, end=' ')
    adj = sorted(graph[start_node], reverse=True)
    adj_stack.extend(adj)
    while adj_stack:
        node = adj_stack.pop()
        if visited[node] == False:
            visited[node] = True
            print(node, end=' ')
            adj = sorted(graph[node], reverse=True)
            adj_stack.extend(adj)
    return


def bfs(start_node):
    visited[start_node] = True
    print(start_node, end=' ')
    adj = sorted(graph[start_node])
    adj_queue.extend(adj)
    while adj_queue:
        node = adj_queue.popleft()
        if visited[node] == False:
            visited[node] = True
            print(node, end=' ')
            adj = sorted(graph[node])
            adj_queue.extend(adj)
    return


dfs(v)
print()

visited = [False for _ in range(n+1)]

bfs(v)

```

---

## 1325. íš¨ìœ¨ì ì¸ í•´í‚¹

ì¼ë°˜ì ìœ¼ë¡œ nì˜ ê°¯ìˆ˜ê°€ ë§ì„ ë•ŒëŠ” BFSê°€ DFSë³´ë‹¤ ë” íš¨ìœ¨ì ì´ë¼ê³  ì•Œë ¤ì ¸ ìˆë‹¤.

### ğŸš« ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ (ì‹œê°„ì´ˆê³¼)

```python
from collections import deque
import sys
n, m = map(int, sys.stdin.readline().split())
adj = [[] for _ in range(n+1)]
visited = [0 for _ in range(n+1)]

for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
    adj[b].append(a)


def bfs(node):
    result = 0
    visited_node = [0]*(n+1)
    need_visit = deque([node])
    visited_node[node] = 1
    while need_visit:
        current_node = need_visit.popleft()
        
        result += 1
        for adj_node in adj[current_node]:
            if not visited_node[adj_node]:
                need_visit.append(adj_node)
                visited[adj_node] = 1
    return result

result = [0 for _ in range(n+1)]

for node in range(1, n+1):
    if not visited[node]:
        visited[node] = 1
        result[node] = bfs(node)

max_num = max(result)
result_list = []
for i in range(1, n+1):
    if max_num == result[i]:
        result_list.append(i)

sorted_result = sorted(result_list)
for answer in sorted_result:
    print(answer, end=' ')
```

### ë‹µì•ˆ ì½”ë“œ

```python
from collections import deque
n, m = map(int, input().split())
adj = [[] for _ in range(n + 1)]
for _ in range(m):
    x, y = map(int, input().split())
    adj[y].append(x)
    
def bfs(v):
q = deque([v])
    visited = [False] * (n + 1)
    visited[v] = True
    count = 1
    while q:
        v = q.popleft()
        for e in adj[v]:
          if not visited[e]:
            q.append(e)
            visited[e] = True
            count += 1
    return count
  
result = []
max_value = -1

for i in range(1, n + 1):
    c = bfs(i)
    if c > max_value: 
      result = [i]
      max_value = c
    elif c == max_value:
        result.append(i)
        max_value = c

for e in result: 
  print(e, end=" ")
```

### ë‹µì•ˆ ì½”ë“œ ë³´ê³  ìˆ˜ì •í•´ë³¸ ì½”ë“œ

```python
from collections import deque
import sys
n, m = map(int, sys.stdin.readline().split())
adj = [[] for _ in range(n+1)]
visited = [0 for _ in range(n+1)]

for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
    adj[b].append(a)


def bfs(node):
    visited_node = [0]*(n+1)
    need_visit = deque([node])
    visited_node[node] = 1
    count = 1
    while need_visit:
        current_node = need_visit.popleft()
        result += 1
        for adj_node in adj[current_node]:
            if not visited_node[adj_node]:
                need_visit.append(adj_node)
                visited[adj_node] = 1
                visited_node[adj_node] = 1
                count += 1
    return result

result = [0 for _ in range(n+1)]

for node in range(1, n+1):
    if not visited[node]:
        visited[node] = 1
        result[node] = bfs(node)

max_num = max(result)
result_list = []
for i in range(1, n+1):
    if max_num == result[i]:
        result_list.append(i)

sorted_result = sorted(result_list)
for answer in sorted_result:
    print(answer, end=' ')
```

ë¶€ë“¤ë¶€ë“¤ íŒŒì´ì¬ìœ¼ë¡œëŠ” ì‹œê°„ì´ˆê³¼ ë‚˜ëŠ” ë¬¸ì œì˜€ë‹¤ PyPyë¡œ í’€ì–´ì•¼ í•¨