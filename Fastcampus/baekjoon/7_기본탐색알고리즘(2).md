# 7. ê¸°ë³¸ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ (2)

**ì´ì§„íƒìƒ‰ ìœ í˜•**ì€ êµ¬í˜„ì´ ê°„ë‹¨í•˜ì§€ ì•Šê³  ì‹¤ìˆ˜í•˜ê¸° ì‰½ë‹¤. ì¡°ì‹¬í•´ì„œ í’€ì–´ì•¼í•©ë‹ˆë‹¹ë‹¹
ì´ì§„íƒìƒ‰ì€ (1) ì¬ê·€ì  (2) ë°˜ë³µì  ë‘ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ë°, ì¬ê·€ë³´ë‹¤ëŠ” ë°˜ë³µì´ ë” í’€ê¸°ì— ì‰¬ìš´ ê²½ìš°ê°€ ë§ë‹¤.

## 2110. ê³µìœ ê¸° ì„¤ì¹˜ â­ï¸

ë¬¸ì œ ìœ í˜•: `ì´ì§„ íƒìƒ‰`, ë‚œì´ë„: `ì¤‘`

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

1) ì§‘ì˜ ê°œìˆ˜ Nì€ ìµœëŒ€ 200,000 ì´ë©°, ì§‘ì˜ ì¢Œí‘œ XëŠ” ìµœëŒ€ 1,000,000,000 (10ì–µğŸ˜³) ì´ë‹¤. ë”°ë¼ì„œ ì´ì§„ íƒìƒ‰ì„ ì´ìš©í•˜ë©° O(N*logX) ì— ë¬¸ì œë¥¼ í•´ê²°í•´ì•¼ í•¨
2) ì´ë ‡ê²Œ ë°ì´í„°ì˜ ê°œìˆ˜/ë²”ìœ„ê°€ ë¬´ì§€ë§‰ì§€í•˜ê²Œ í° ê²½ìš°ì—ëŠ” í•œë²ˆ íƒìƒ‰í• ë•Œë§ˆë‹¤ ê³ ë ¤í•˜ëŠ” ë²”ìœ„ê°€ ë°˜ìœ¼ë¡œ ì¤„ì–´ë“œëŠ” **ì´ì§„íƒìƒ‰**ì„ ê³ ë ¤í•´ì•¼ í•¨. log10ì–µ = 30ì •ë„ë¡œ ì¤„ì–´ë“¤ê¸° ë•Œë¬¸ :)

### ì½”ë“œ ì‘ì„±

#### ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ

```python
import sys
N, C = map(int, sys.stdin.readline().split())
homes = list()
for _ in range(N):
    homes.append(int(sys.stdin.readline()))
homes.sort()

min_gap = 1
max_gap = homes[-1] - homes[0]

while min_gap != max_gap:
    target = set()
    i, j = 0, 1
    mid_gap = (max_gap + min_gap)//2
    if max_gap - min_gap == 1:
        mid_gap += 1
    while j < N:
        if homes[j]-homes[i] >= mid_gap:
            target.add(i)
            target.add(j)
            i, j = j, j+1
        else:
            j += 1
    if len(target) >= C:
        min_gap = mid_gap
    elif len(target) < C:
        max_gap = mid_gap-1
# ì´ê±¸ mid_gap ìœ¼ë¡œ í•˜ë©´ ì˜¤ë‹µ íŒì • ë‚¨.
# min=max!=mid ì¸ ê²½ìš°ë„ ìˆëŠ” ê²ƒ ê°™ìŒ
print(min_gap)
```

Cì™€ ê°™ì•„ì§€ëŠ” ê²½ìš°ì˜ mid_gapì„ ì°¾ì•˜ì„ ë•Œ, ê·¸ ì¤‘ì—ì„œì˜ ìµœëŒ€ë¥¼ ì°¾ëŠ” ê²ƒì´ ì–´ë ¤ì› ìŒ.
ë˜, min ê°’ê³¼ max ê°’ì´ 1ì°¨ì´ë§Œ ë‚ ë•Œ ì–´ë–»ê²Œ í• ì§€ë„...

#### ë‹µì•ˆ ì½”ë“œ

```python
n, c = list(map(int, sys.stdin.readline().split()))

array = []
for _ in range(n):
  array.append(int(input()))
array = sorted(array)

start = array[1]-array[0] 
end = array[-1]-array[0]
result = 0

while(start <= end):
  mid = (start + end) // 2
  value = array[0]
  count = 1
  for i in range(1,len(array)):
    if array[i] >= value + mid:
      value = array[i]
      count += 1
  if count >= c:
    start = mid + 1
    result = mid # resultì— í˜„ì¬ ê°€ëŠ¥í•œ ìµœëŒ€ê°’ì„ ì—…ë°ì´íŠ¸ í•˜ë©´ ëœë‹¤
  else:
    end = mid -1
print(result)
```
- start ë¥¼ ê¼­ 1ìœ¼ë¡œ ì„¤ì •í•  í•„ìš”ê°€ ì—†êµ°. array[1] - array[0] ì„ í•´ì£¼ë©´ ë˜ëŠ”êµ°
- ê¶‚ì´ start ì™€ end ê°’ì´ **ê°™ì•„ì•¼ì§€ë§Œ** ë°˜ë³µë¬¸ì„ íƒˆì¶œí•  í•„ìš”ëŠ” ì—†êµ°. 
- ê°€ëŠ¥í•œ mid ê°’ì¸ ê²½ìš°, result ì— **ì €ì¥**í•´ë‘ê³  mid+1ì„ startë¡œ ë‘ë©´ ë˜ëŠ”êµ°. ìƒˆë¡œìš´ start ë¡œ ë¶ˆê°€ëŠ¥ í•  ê²½ìš° ì–´ì°¨í”¼ resultê°€ ì—…ë°ì´íŠ¸ ë˜ì§€ ì•Šì€ ì±„ë¡œ while ë¬¸ì„ íƒˆì¶œí• í…Œë‹ˆ
- ë§¨ ì•ë¶€í„° ê³µìœ ê¸°ë¥¼ ìŒ“ìœ¼ë©´ ë˜ë‹ˆ, i/j 2ê°€ì§€ ë³€ìˆ˜ë¡œ ì¸ë±ìŠ¤ë¥¼ ê´€ë¦¬í•  í•„ìš” ì—†ì´ ëª¨ë“  ì§‘ë“¤ì„ í•œë°”í€´ ëŒë©´ì„œ ì´ì „ ì§‘ ( = ì´ˆê¸°ê°’ì€ ì²«ë²ˆì§¸ ì§‘. ê³µìœ ê¸° ì„¤ì¹˜í•  ë•Œë§ˆë‹¤ ì„¤ì¹˜í•œ ì§‘ìœ¼ë¡œ update) ì—ì„œ gap ë§Œí¼ì„ ë”í•œê°’ë³´ë‹¤ ì‘ì€ì§€ ì•„ë‹Œì§€ë¥¼ ë³´ë©´ ë˜ëŠ”êµ°. â­ï¸
- ì‹œê°„ë³µì¡ë„ëŠ” while ë¬¸ì´ log10ì–µ (==30), while ë¬¸ ì•ˆì˜ forë¬¸ì´ 20ë§Œ ì •ë„ì´ê¸°ì— 20ë§Œ*30 ì¦‰ 600ë§Œ ì •ë„ì˜ ì—°ì‚°íšŸìˆ˜ë¡œ ë¬¸ì œë¥¼ í’€ ìˆ˜ ìˆë‹¤.

---

## 1939. ì¤‘ëŸ‰ì œí•œ â­ï¸â­ï¸

ë¬¸ì œ ìœ í˜•: `ì´ì§„ íƒìƒ‰` ë‚œì´ë„: `ì¤‘ìƒ`

### ë¬¸ì œ í’€ì´ ì•„ì´ë””ì–´

1) ì°¾ê³ ì í•˜ëŠ” ì¤‘ëŸ‰ì œí•œì¸ Cê°€ ìµœëŒ€ 10ì–µ. ë”°ë¼ì„œ ì´ê²ƒë„ ì¼ë°˜ì ì¸ ë°©ë²•ìœ¼ë¡œëŠ” íƒìƒ‰ì´ ë¶ˆê°€ëŠ¥í•˜ê³  logë‚˜ ë£¨íŠ¸ê°€ ì”Œì›Œì§ˆë§Œí•œ ì´ì§„íƒìƒ‰ì„ ê³ ë ¤í•´ë³´ì•„ì•¼ í•¨. ì´ì§„íƒìƒ‰ì„ ì´ìš©í•´ **O(MlogC)**ì— ë¬¸ì œ í•´ê²°.
2) BFSëŠ” ëª¨ë“  ê°„ì„ (=ë‹¤ë¦¬)ì— ëŒ€í•´ ë°˜ë³µí•˜ê¸°ì— O(M) ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§€ê³ , ë°˜ë³µí•  ë•Œë§ˆë‹¤ ì¤‘ëŸ‰ì œí•œì— ë¡œê·¸ë¥¼ ì”Œìš´ ê°’ì¸ logC ë§Œí¼ì„ íƒìƒ‰í•˜ë¯€ë¡œ ì „ì²´ ì‹œê°„ë³µì¡ë„ëŠ” O(MlogC) = ì•½ 300ë§Œ

#### ë‚´ê°€ ì‘ì„±í•œ ì½”ë“œ

```python
BFS ì•Œê³ ë¦¬ì¦˜ ì ìš© ëª»í•´ì„œ ëª»í’€ìŒ
```

#### ë‹µì•ˆ ì½”ë“œ

```python
from collections import deque

n, m = map(int, input().split())
adj = [[] for _ in range(n+1)]

def bfs(c):
  queue = deque([start_node])
  visited = [False] * (n+1)
  visited[start_node] = True
  while queue:
    x = queue.popleft()
    for y, weight in adj[x]:
      if not visited[y] and weight >= c:
        visited[y] = True
        queue.append(y)
  return visited[end_node]
  
start = 1000000000
end = 1

for _ in range(m):
  x,y,weight = map(int,input().split())
  adj[x].append((y, weight))
  adj[y].append((x, weight))
  start = min(start, weight)
  end = max(end, weight)
start_node , end_node = map(int, input().split())

result = start
while(start <= end):
  mid = (start+end)//2
  if bfs(mid):
    result = mid
    start = mid +1
  else:
    end = mid-1

print(result)
```

#### ìˆ˜ì •í•œ ì½”ë“œ âœ…

```python
from collections import deque
import sys


N, M = map(int, sys.stdin.readline().split())
adj = [[] for _ in range(N+1)]

min_weight = 1000000000
max_weight = 0


def bfs(c):
    visited = [False] * (N+1)
    visited[start_node] = True
    check_adj = deque([start_node])
    while check_adj:
        node = check_adj.popleft()
        for y, weight in adj[node]:
            if not visited[y] and c <= weight:
                visited[y] = True
                check_adj.append(y)
    return visited[end_node]


for i in range(M):
    x, y, weight = map(int, sys.stdin.readline().split())
    adj[x].append((y, weight))
    adj[y].append((x, weight))
    min_weight = min(weight, min_weight)
    max_weight = max(weight, max_weight)

start_node, end_node = map(int, sys.stdin.readline().split())
result = min_weight

while min_weight <= max_weight:
    mid_weight = (min_weight + max_weight) // 2
    if bfs(mid_weight):
        result = mid_weight
        min_weight = mid_weight + 1
    else:
        max_weight = mid_weight - 1

print(result)
```

[í—·ê°ˆë ¸ë˜ ë¶€ë¶„]

ì™œ ì–˜ëŠ” ì‹œê°„ì´ˆê³¼ì´ê³ 

```python
def bfs(c):
    need_visit = deque([start_node])
    visited = [False] * (N+1)
    while need_visit:
        node = need_visit.popleft()
        visited[node] = True
        for y, weight in adj[node]:
            if not visited[y] and c <= weight:
                need_visit.append(y)
    return visited[end_node]
```

ì™œ ì–˜ëŠ” ë§ëŠ”ê°€?

```python
def bfs(c):
    need_visit = deque([start_node])
    visited = [False] * (N+1)
    visited[start_node] = True
    while need_visit:
        node = need_visit.popleft()
        for y, weight in adj[node]:
            if not visited[y] and c <= weight:
                visited[y] = True
                need_visit.append(y)
    return visited[end_node]
```

ì´ë¡ ì‹œê°„ì— ë°°ì› ë˜ ë”•ì…”ë„ˆë¦¬ êµ¬ì¡°ì™€ ì¡°ê¸ˆ ë‹¬ë¼ì„œ í—·ê°ˆë ¸ë˜ ê²ƒ ê°™ë‹¤.
ë”•ì…”ë„ˆë¦¬ì—ì„œëŠ” need_visit ìœ¼ë¡œ ì‚¬ìš©í–ˆì§€ë§Œ ì§€ê¸ˆ í(check_adj) ì— ë“¤ì–´ê°€ìˆëŠ” ë…¸ë“œë“¤ì€ **ì´ë¯¸ ë°©ë¬¸í•œ** ë…¸ë“œì´ê³ , **ê·¸ ë…¸ë“œë“¤ì˜ ìì‹ë“¤ì„ ì²´í¬í•´ì•¼ í•¨**ì„ ì˜ë¯¸í•œë‹¤.
ë”°ë¼ì„œ `if not visited[y] and c<= weight` ì´ë¼ë©´ í•´ë‹¹ ë…¸ë“œì˜ ìì‹ì´ **ë°©ë¬¸í•  ìˆ˜ ìˆëŠ”** ë…¸ë“œë€ ëœ»ì´ê³ , ë°©ë¬¸í–ˆìŒì— ì²´í¬í•œ ë’¤ need_visit ì— yë¥¼ ë„£ì–´ì£¼ë©´ ëœë‹¤.

### Lesson learned

#### BFS, DFS ë³µìŠµ

BFS : visited, need_visit **ëª¨ë‘ queue** ì‚¬ìš©
DFS : visited ëŠ” queue, need_visitì€ **stack** ì‚¬ìš© 

ë‘ê°œ ëª¨ë‘ O(V+E) ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§