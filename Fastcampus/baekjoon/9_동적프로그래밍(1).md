# 9. 동적 프로그래밍 (1)

최적화 문제에서 많이 사용되는 동적 프로그래밍 (조합 최적화, 최단경로 등)

동적 프로그래밍의 특징은? **한번 계산한 값은 다시 구하지 않는다**!
작은 문제에서 구한 값을 리스트 등에 **저장**( = memoization) 해뒀다가, 나중에 큰 값에 대해 그냥 예전에 계산했던 값을 반환해주는 식.

동적 프로그래밍 문제를 풀기 위해서는 **점화식(인접한 항들 사이의 관계식)** 을 세워야 함.

## 1904. 01타일

문제 유형: `동적 프로그래밍`, 난이도: `하`

### 문제 풀이 아이디어

1) 가장 전형적이고 쉬운 동적 프로그래밍 문제. N이 최대 1,000,000이므로 시간 복잡도 O(N) 으로 해결해야 함
2) 타일을 왼쪽에서 오른쪽으로 이어서 붙인다고 가정했을 때, 길이가 i인 수열을 형성하는 방법은 길이 i-1짜리 타일에 1을 붙이거나, 길이 i-2 타일에 00을 붙이거나 둘 중에 하나!
3) 즉, D[i] = D[i-1] + D[i-2]

####  내가 작성한 코드

```python
import sys
n = int(sys.stdin.readline())

data = [0 for i in range(n+1)]

for i in range(1, n+1):
    if i <= 2:
        data[i] = i % 15746
    else:
        data[i] = data[i-1] % 15746 + data[i-2] % 15746

print(data[n] % 15746) # 마지막엔 15746 나머지 궂이 안해줘도 되는 듯
```

피보나치와 유사한 문제군

#### 답안 코드

```python
import int(input())

dp = [0] * 1000001
dp[1] = 1
dp[2] = 2

for i in range(3, n+1):
  dp[i] = (dp[i-2] + dp[i-1]) % 15746 # 값을 작게 만들기 위해 보통 나머지 값을 요구하는 경우가 많음.
  
print(dp[n])
```
---

## 12865. 평범한 배낭

문제 유형: `동적 프로그래밍` 난이도: `하`

가장 많이 물어보는 예제로, **0/1 knapsack problem** 이다. 조합 최적화의 유명한 문제.
짐을 쪼갤 수 있는 경우는 **Fractional Knapsack Problem** 으로, Greedy 알고리즘을 사용하고,
이 문제처럼 짐을 쪼갤 수 없는 경우는 **0/1 Knapsack Problem** 으로, DP를 사용한다.

### 문제 풀이 아이디어

1) 전형적인 동적 프로그래밍 문제
2) 물품의 수가 N, 배낭에 담을 수 있는 무게가 K
3) 동적 프로그래밍을 이용하여 **시간복잡도 O(NK)**로 문제를 해결할 수 있음
4) 모든 무게에 대해서 최대 가치를 저장해야 한다 

#### 내가 작성한 코드 

```python
햐 진짜 생각하기 어렵다
```

#### 답안 코드

**D[i\][j]**, 즉 **2차원 배열**로 구성해야 한다는 것이 핵심. 그 이유는 모든 k에 대해 모든 i를 고려한 경우를 다 저장해야 하기 때문.

처음에는 i0 만을 고려한 모든 무게에 대한 최대 가치를, 다음에는 i1까지 고려한 모든 무게에 대한 최대 가치를...
최대 가치를 정할 땐 이 아이템을 넣을까 말까
(1) 넣을 경우 최대가치는 방금 넣은 아이템의 가치 + 직전 아이템까지 고려한 테이블에서의 j-w 용량에서의 최대가
 (2) 안넣을 경우 최대가치는 직전 아이템까지 고려한 테이블에서의 j 용량에서의 최대가치

```python

```

----

## 11053. 가장 긴 증가하는 부분 수열

문제 유형: `동적 프로그래밍, LIS` 난이도: `하`

### 문제 풀이 아이디어

1) 가장 긴 증가하는 부분 수열 (LIS) 문제는, 전형적인 동적 프로그래밍 문제이다
2) 수열의 크기가 N일 때, 기본적인 동적 프로그래밍 알고리즘으로 O(N^2)에 해결할 수 있음

#### 내가 작성한 코드

수열 A의 크기가 N (1000이하) 이고, 한 숫자의 범위가 1000이하이므로 1001만큼의 배열을 선언해두고 (ascending), 숫자 n까지의 가장 긴 증가하는 부분 수열은 n 미만의 숫자들 중 가장 긴 증가하는 부분 수열의 값이다. 이렇게 풀었음.

```python
import sys
n = int(sys.stdin.readline())
ascending = [0 for i in range(1001)]
numbers = map(int, sys.stdin.readline().split())

for number in numbers:
    ascending[number] = max(ascending[:number]) + 1

print(max(ascending))
```

#### 답안 코드

나는 각 원소의 숫자 범위가 1000이라 1001 만큼의 배열을 잡아뒀는데, 답안 코드에서는 수열의 길이만큼 배열을 잡아두고, 별도로 data를 array에 잡아둔 뒤 인덱스를 통해 숫자를 가져와서 활용함.

이게 훨씬 효율적이군!

D[i] = array[i] 를 마지막 원소로 가지는 부분 수열의 최대 길이 (일반항)
점화식: 모든 0<=j<i 에 대하여 **D[i] = max(D[i], D[j]+1) if array[j] < array[i]**

```python
n = int(input())
array = list(map(int,input().split()))
dp = [1]*n # 수열의 길이 만큼 dp 배열을 초기화 (default : 1)

# 이중 for 문이므로 시간복잡도는 n^2
for i in range(1,n):
  for j in range(0,i):
    if array[j] < array[i]: # i보다 j가 작다면
      dp[i] = max(dp[i], dp[j]+1)
      
print(max(dp))
```
롸 근데 시간 자체는 비슷하네 '_' 흠

### Lesson learned

가장 긴 증가하는 수열 문제는 수열의 크기가 N일 때, DP로 **O(N^2)**에 해결할 수 있다는 점.