# 동적 계획법 (Dynamic Programming) 과 분할 정복 (Divide and Conquer)

## 1. 정의

### 동적계획법

- 입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제의 해를 활용해서, 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 알고리즘
- **상향식 접근법**으로, 가장 최하위 해답을 구한 후, 이를 저장하고, 해당 결과값을 이용해서 상위 문제를 풀어가는 방식
- Memoization (프로그램 실행 시 이전에 계산한 값을 저장하여, 다시 계산하지 않도록 하여 전체 실행 속도를 빠르게 하는 기법) 을 사용함

- 문제를 잘게 쪼갤 때, **부분 문제는 중복되어, 재활용됨**
- Ex) 피보나치 수열

### 분할 정복

  - 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘
  - **하향식 접근**법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식이며 일반적으로 재귀함수로 구현
  - 문제를 잘게 쪼갤 때,  **부분 문제는 서로 중복되지 않음**
- Ex) 예: 병합 정렬, 퀵 정렬 등

### DP와 분할정복의 공통점과 차이점

공통점 : 큰 문제를 작은 문제로 쪼갠다

차이점 : 

- 동적 계획법
  - 부분 문제는 중복되어, 상위 문제 해결 시 재활용됨
  - Memoization 기법 사용 (부분 문제의 해답을 저장해서 재활용하는 최적화 기법으로 사용)
- 분할 정복
  - 부분 문제는 서로 중복되지 않음
  - Memoization 기법 사용 안함

## 2. 동적 계획법 알고리즘 이해

### 피보나치 수열

```python
# 재귀 함수 활용
def recursive_fibonacci(n):
    if n <= 1:
        return n
    return recursive_fibonacci(n-1) + recursive_fibonacci(n-2)
```

#### 피보나치 수열을 재귀 함수로 풀었을 때의 단점은?

불필요하게 계산한 함수를 또 다시 계산한다는 단점이 있다. (메모리 낭비, 시간 낭비)

#### 동적 계획법으로 풀어본 피보나치 수열

참고: 파이썬의 list comprehension`

` list [ ( 변수를 활용한 값 ) for ( 사용할 변수 이름 ) in ( 순회할 수 있는 값 )]`
`예시: doubled_arr = [i * 2 for i in range(size)]`

```python
def dp_fibonacci(n):
    cache = [0 for i in range(n+1)]
    cache[0] = 0
    cache[1] = 1
    # 매번 다시 계산하는 것이 아니라, 이미 계산된 cache 배열에서 값을 가져옴 (=재활용)
    for index in range(2, n + 1):
        cache[index] = cache[index-1] + cache[index-2]
    return cache[n]
```

## 3. 분할 정복

분할 정복은 이후 별도로 다루는 병합 정렬과 퀵 정렬을 통해 이해.