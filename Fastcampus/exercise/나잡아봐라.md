# ë‚˜ ì¡ì•„ ë´ë¼

### ğŸš« ì²˜ìŒ ì‘ì„±í–ˆë˜ ì½”ë“œ (í‹€ë¦¼)

- ì–´ë ¤ì›€ì„ ê²ªì—ˆë˜ ë¶€ë¶„ 1 - ê³„ì†í•´ì„œ ë³€í™”í•˜ëŠ” ì½”ë‹ˆì˜ ìœ„ì¹˜ë¥¼ ì–´ë–»ê²Œ ì €ì¥í•  ê²ƒì¸ê°€
- ì–´ë ¤ì›€ì„ ê²ªì—ˆë˜ ë¶€ë¶„ 2 - 1,2,3,4...ë¡œ ê³µì°¨ê°€ 1ì”© ì¦ê°€í•˜ëŠ” ì‹œê°„ì„ ì–´ë–»ê²Œ ê´€ë¦¬í•  ê²ƒì¸ê°€

```python
import sys
from collections import deque

limit = 200000
c, b = map(int, sys.stdin.readline().split())
time = [0 for _ in range(limit+1)]
current_c = [0 for _ in range(limit+1)]
queue = deque([b])
current_c[b] = 11


def catch():
    global c
    while queue:
        current_b = queue.popleft()
        if current_b == current_c[current_b]:
            return(time[current_b])
        for next_b in [current_b+1, current_b-1, current_b*2]:
            if 0 <= next_b <= limit and time[next_b] == 0:
                time[next_b] = time[current_b] + 1
                current_c[next_b] = current_c[current_b] + time[next_b]
                queue.append(next_b)
        if c > limit:
            return -1


print(catch())
```

í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ë§ì•„ì„œ ë§ì€ì¤„ã…ã… í•˜í•˜ ì–´ë¦¼ë„ ì—†ì§€!

### í‹€ë¦° ì´ìœ ğŸ˜” [ì°¸ê³  ë§í¬](https://engineering.linecorp.com/ko/blog/2019-firsthalf-line-internship-recruit-coding-test/)

í‹€ë¦° ì´ìœ : ë™ìƒì˜ ìœ„ì¹˜ê°€ ê³ ì •ë˜ì–´ ìˆì—ˆë˜ ë°±ì¤€ 1697ë²ˆ ìˆ¨ë°”ê¼­ì§ˆ ë¬¸ì œì™€ëŠ” ë‹¬ë¦¬, ì½”ë‹ˆì˜ ìœ„ì¹˜ê°€ ê³„ì†í•´ì„œ ë°”ë€ë‹¤.

ê·¸ ë§ì¸ ì¦‰ìŠ¨, **ì´ë¯¸ t ì‹œê°„ì— ë°©ë¬¸í–ˆë˜ ìœ„ì¹˜ë¼ë„** ì‹œê°„ì´ ì§€ë‚˜ ì½”ë‹ˆì˜ ìœ„ì¹˜ê°€ ë‹¬ë¼ì§€ë©´ **ë‹¤ì‹œ ë°©ë¬¸**í•´ì•¼ í•œë‹¤ëŠ” ê²ƒ. ìˆ¨ë°”ê¼­ì§ˆë•Œì²˜ëŸ¼ í•¨ìˆ˜ ì‹œê°„ì´ t1ì¼ë•Œ ì½”ë‹ˆì™€ ë¸Œë¼ìš´ì˜ ìœ„ì¹˜ê°€ ê°™ìœ¼ë©´ ì¡ì•˜ë‹¤ - ê³  ì•Œê³ ë¦¬ì¦˜ì„ ì‘ì„±í•˜ë©´ í‹€ë¦°ë‹¤. ex. ì½”ë‹ˆ=11, ë¸Œë¼ìš´=1

ìœ„ì˜ ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” í•œë²ˆ ë°©ë¬¸í•œ ê³³ì€ ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì´ë‹¤. `time[next_b] == 0`

ê·¸ëŸ¼ ì–´ë–»ê²Œ í• ê¹Œ? ë²”ìœ„ë¥¼ ë§Œì¡±í•˜ëŠ” ëª¨ë“  ê³³ì— ëŒ€í•´ ì¬ë°©ë¬¸í•˜ëŠ” ê²ƒì€ BFSê°€ ì•„ë‹ˆê³ , ì¤‘ë³µí•´ì„œ íƒìƒ‰í•´ì•¼í•˜ëŠ” ë…¸ë“œì˜ ìˆ˜ê°€ í­â­ï¸ë°œí•˜ë‹ˆ ì‹œê°„ë³µì¡ë„ë„ í­â­ï¸ë°œí•˜ì§€ë¡± 3^nìœ¼ë¡œ.

ì¡°ê¸ˆ ë” ìƒê°í•´ë³´ë©´, ì‹œê°„ tì—ì„œ pìœ„ì¹˜ë¥¼ ë°©ë¬¸í–ˆë‹¤ë©´?

- ë¬¸ì œì˜ ì œí•œì¡°ê±´ ìƒ, t+1ì—ì„œëŠ” ì ˆëŒ€ pìœ„ì¹˜ë¥¼ ë°©ë¬¸í•  ìˆ˜ ì—†ë‹¤
- í•˜ì§€ë§Œ t+2 ì´ˆ, í˜¹ì€ t+4ì´ˆ ì¦‰ ì§ìˆ˜ ì‹œê°„ë§Œí¼ì´ ì§€ë‚œ í›„ì—ëŠ” pìœ„ì¹˜ì— ë°©ë¬¸í•  ìˆ˜ ìˆë‹¤. t > t+1 > t í˜¹ì€ t > t-1 > t ì´ë ‡ê²Œ!
- ë”°ë¼ì„œ ì½”ë‹ˆê°€ tì´ˆ í›„ì— pìœ„ì¹˜ì— ë„ì°©í–ˆì„ ë•Œ, ë¸Œë¼ìš´ì´ t-2k (k>=0) ì‹œê°„ì— ë„ì°©í–ˆëŠ”ì§€ë¥¼ íŒë‹¨í•˜ì—¬ í•´ë‹¹ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” të¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ í•„ìš”í•˜ë‹¤.

### ë‹¤ì‹œ ì‘ì„±í•œ ì½”ë“œ

```python
import sys
from collections import deque


def catch():
    time = 0
    limit = 200000
    visited = [[0]*2 for i in range(limit+1)]
    c, b = map(int, sys.stdin.readline().split())
    q = deque()
    q.append((b, 0))
    while 1:
        c += time
        if c > limit:
            return -1
        if visited[c][time % 2]:
            return time
        for i in range(len(q)): # ì´ ë¶€ë¶„ì´ ê³„ì† í—·ê°ˆë ¸ë‹¤
            current = q.popleft()
            current_position = current[0]
            next_time = (current[1]+1) % 2
            for next_position in [current_position-1, current_position+1, current_position*2]:
                if next_position <= limit and next_position >= 0 and not visited[next_position][next_time]:
                    visited[next_position][next_time] = True
                    q.append((next_position, next_time))
        time += 1


print(catch())
```

- ì§/í™€ìˆ˜ ë‚˜ëˆ ì„œ ì²´í¬í•´ì•¼ í•˜ëŠ” ë¶€ë¶„ì„ ìƒê°ì§€ë„ ëª»í–ˆë‹¤. timeì€ ê·¸ëƒ¥ ë³€ìˆ˜ í•˜ë‚˜ë¡œ ê³„ì†í•´ì„œ ê´€ë¦¬í•˜ë˜ ê° nodeê°€ ë°©ë¬¸ë˜ì—ˆë‹¤ë©´ ë°©ë¬¸í–ˆë˜ ì‹œê°ì´ í™€ìˆ˜ëƒ ì§ìˆ˜ëƒì— ë”°ë¼ [T]\[F] ë˜ëŠ” [F]\[T]ë¡œ í‘œì‹œí•´ì£¼ë©´, ëª¨ë“  ë°©ë¬¸ì§€ì ì— ëŒ€í•´ ë°©ë¬¸ ì‹œê°ì„ ìˆ«ìë¡œ í‘œí˜„í•˜ëŠ” ê²ƒë³´ë‹¤ í›¨ì”¬ í›¨ì”¬ í¸ë¦¬í•˜ë‹¤ëŠ” ì .

BFS, DFSê°€ ì´ë¯¸ ë°©ë¬¸í–ˆë˜ ì§€ì ì€ ì²´í¬í•´ë‘ê³  ì¬ë°©ë¬¸í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì„ í•œë²ˆ ê¼° ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ, ëª©í‘œì§€ì ì´ ê³„ì†í•´ì„œ ë°”ë€” ë•Œ ì´ë¯¸ ë°©ë¬¸í–ˆë˜ ì§€ì ë„ ê³ ë ¤í•´ì•¼ í•œë‹¤ëŠ” ì ì„ ì•Œì•„ì°¨ë¦¬ëŠ”ê²Œ í¬ì¸íŠ¸.

ì´ë¯¸ ë°©ë¬¸í–ˆë˜ ì§€ì ì„ ê³ ë ¤í•˜ë ¤ë©´? c ì§€ì ì„ ë°©ë¬¸í–ˆë˜ ì‹œê°„ì´ pë¼ë©´ p+2 ì— ë¬´ì¡°ê±´ í•´ë‹¹ ì§€ì ì„ ë°©ë¬¸í•  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ visited[c] ì˜ í™€/ì§ì´ í˜„ì¬ ì‹œê°„ì˜ í™€/ì§ê³¼ ê°™ì€ì§€ë¥¼ ì²´í¬í•˜ë©´ ë¨.

- `for i in range(len(q))` ì´ ë¶€ë¶„ì— ë°˜ë³µë¬¸ì„ ë„£ì–´ì£¼ëŠ” ê²ƒì´ ì–´ë ¤ì› ë‹¤. 

2/1,3,4/0/6/5/8 ì´ëŸ° ì‹ìœ¼ë¡œ depthê°€ ê¹Šì–´ì§ˆ ë•Œë§ˆë‹¤ ì½”ë‹ˆì˜ ìœ„ì¹˜ê°€ ë‹¬ë¼ì§€ê³  ì‹œê°„ì´ ë‹¬ë¼ì§„ë‹¤. ì¦‰, 1,3,4ëŠ” ê°™ì€ c, time ì„ ê³µìœ í•´ì•¼ í•˜ë¯€ë¡œ. ì²˜ìŒì—ëŠ” 1ë²ˆì˜ loop, ë‹¤ìŒì—ëŠ” 3ë²ˆì˜ loop...

```python
def catch():
  	# ì´ˆê¸°í™” ë¶€ë¶„
    time = 0
    limit = 200000
    visited = [[0]*2 for i in range(limit+1)]
    c, b = map(int, sys.stdin.readline().split())
    q = deque()
    q.append((b, 0))
    # loop1 (ì‹œê°„ê³¼ ì½”ë‹ˆì˜ ìœ„ì¹˜ ì—…ë°ì´íŠ¸)
    while 1:
        c += time
        if c > limit:
            return -1
        if visited[c][time % 2]:
            return time
         # loop2 (ë‹¤ìŒ depthì— ëŒ€í•´ visitedì™€ që¥¼ ì—…ë°ì´íŠ¸)
        for i in range(len(q)): # ì´ ë¶€ë¶„ì´ ê³„ì† í—·ê°ˆë ¸ë‹¤
            current = q.popleft()
            current_position = current[0]
            next_time = (current[1]+1) % 2
            for next_position in [current_position-1, current_position+1, current_position*2]:
                if next_position <= limit and next_position >= 0 and not visited[next_position][next_time]:
                    visited[next_position][next_time] = True
                    q.append((next_position, next_time))
        time += 1
```

while ë¬¸ ë§ê³  ë°˜ë³µíšŸìˆ˜ê°€ ì •í•´ì§„ forë¬¸ì„ ì‚¬ìš©í•´, ì²˜ìŒ qì˜ length ë§Œí¼ë§Œ ë°˜ë³µë¬¸ì„ ëŒì•„ì•¼ í•œë‹¤. (whileì„ ì“°ë©´ ë°˜ë³µë¬¸ ì•ˆì—ì„œ ê³„ì†í•´ì„œ qì— appendê°€ ë˜ê¸° ë•Œë¬¸ì— ì›í•˜ëŠ” ê²ƒì²˜ëŸ¼ ì‘ë™í•˜ì§€ ì•ŠëŠ”ë‹¤)

ë°˜ë³µë¬¸ì„ ë‹¤ ëˆë‹¤ëŠ” ê²ƒì€ í•´ë‹¹ levelì„ ë‹¤ ëŒê³  visitedì™€ queueë¥¼ ì—…ë°ì´íŠ¸ í–ˆìŒì„ ì˜ë¯¸í•˜ë©°,
ë‹¤ìŒ whileë¬¸ì—ì„œ í•´ë‹¹ ì‹œê°„ (í˜¹ì€ t-2k) ì— ì½”ë‹ˆì˜ ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì•Œ ìˆ˜ ìˆê²Œ ëœë‹¤.