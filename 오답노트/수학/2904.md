# 2904. 수학은 너무 쉬워

수학이 너무 쉽긴 개뿔이 쉽냐 👿

소수 구하는 에라토스테네스의 체 + 에라토스테네스의 체 이용한 소인수분해 활용이 주가 된 문제였다.
처음 아이디어는 다음과 같았다.

1. 모든 수를 곱한 total num 을 소인수분해한다.
2. 총 숫자의 개수가 n이면, 소인수분해된 숫자들 중 지수가 n보다 큰 소인수를 n으로 나눈 몫만큼 공평하게 곱할수 있고, 따라서 해당 소인수는 gcd에 포함될 수 있다.
3. 몇 번만에 해당 점수를 얻을 수 있는가는, gcd에 있는 소인수보다 적게 가지고 있는 (혹은 gcd에 있는 소인수를 가지고 있지 않은) 인수들의 지수값을 다 누적한 값이다.

- 먼저 실수한 부분은 get_factorization을 할 때마다 get_primes를 했던 것. 이렇게 되면 모든 수에 대해 소수찾기를 계속해서 시행해야 한다. 소수는 **최대값**에 대해 한번만 수행해서 구해놓고 그 값을 해결하면 된다. 모든 원소를 다 곱해서 factorized_total 을 구하고, 해당 수에 get_factorization을 시행했는데 그럼 100*100,000 즉 1억이라는 수에 대해 get_factorization을 시행하게 된다. 이러면 에러난다. 
- 그 다음 실수한 부분은 factorized_total을 구할 때의 부분. 앞서 말한 것처럼 factorized_total 은 최대 1억이 될 수 있으므로 조심해서 구해야 하는데, 나는 소수의 최대값 (1000000 이하의 수가 입력되므로, 최고로 큰 소수는 999983 이다.) 만큼의 배열을 선언하고, 모든 소인수를 돌면서 해당 소수 부분에 + 해주는 식으로 factorized_total 을 구했다.

- 마지막 실수한 부분은 "max_count" 부분. 몇 번만에 해당 점수를 얻을 수 있는지는 max count 값이 아니라, gcd 보다 적게 가지고 있는 요소의 필요 값을 누적했어야 했다. 예제만 보고 잘못 생각했었는데 반례는 다음과 같다. gcd 보다 더 많은 소인수를 가지고 있는 원소는 고려할 필요가 없다는 것!

```python
3
96 18 1 # 3이 아니라 4가 나와야 함
```