# Week 3

## [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/explore/featured/card/march-leetcoding-challenge-2021/590/week-3-march-15th-march-21st/3674/)

뭔가 DP라는건 감이 오는데... DP 푸는 법을 까먹어삐따...🤭 너무 쉬었다...하나도 기억이 안난다...그래서 답지를 봤습니다...

자 생각을 해보자.

price가 k인 i시점에서, 내가 취할 수 있는 행동은 아래와 같다.

- 기존에 주식이 있을 때
  - k 가격에 주식 팔기
  - 아무것도 안하기 (기존 주식 팔지 않고 유지하기)
- 기존에 주식이 없다면
  - k 가격에 주식 사기
  - 아무것도 안하기 (주식 사지 않기)

기존에 주식이 있을 때와 없을때로 나눠야 한다는 느낌이 살살 온다. i > i+1 단계에서의 변화를 생각해 보면 아래와 같은 표로 정리 가능하다. 표 안에 들어가는 값은 "현재 보유하고 있는 현금" 이다.

transaction fee는 판매할 때만 3씩 부과된다고 가정한다.

| 변화 상태 / 주식 가격 | 1                             | 3             | 7                     | 5            | 10                    | 3                |
| --------------------- | ----------------------------- | ------------- | --------------------- | ------------ | --------------------- | ---------------- |
| 주식 보유 > 미보유    | x (처음엔 주식 보유가 불가능) | -1+3-3 = -1   | -1+7-3 = **3** : cash | -1+5-3= 1    | -1+10-3= **6** : cash | -1+3-3= -1       |
| 주식 미보유 > 미보유  | **0** : cash                  | **0** : cash  | 0                     | **3**: cash  | 3                     | **6**: cash      |
| 주식 미보유 > 보유    | **-1** : hold                 | 0-3: -3       | 0-7: -7               | 3-5= -2      | 3-10: -7              | 6-3= **3**: hold |
| 주식 보유 > 보유      | x (처음엔 주식 보유가 불가능) | **-1** : hold | **-1** : hold         | **-1**: hold | **-1**: hold          | -1               |

잘 보면 2개의 값을 트래킹해야 한다는 것을 알 수 있다. i 시점의 마지막에 **주식을 보유했을때의 현금**과, **주식을 보유하지 않은 경우의 현금**을 따로 관리해야 한다. 주식 보유 여부에 따라 다음 단계에서 주식을 파는게 가능한지 여부가 달라지기 때문에.

주식을 보유하지 않았을 때의 현금을 cash, 주식을 보유했을 때의 현금을 hold라고 하면 아래와 같은 점화식이 도출 가능하다.

```python
cash = max(cash, hold+price[i]-fee) # 주식 미보유 > 미보유, 주식 보유 > 미보유 중 최대값
hold = max(hold, cash-price[i]) # 주식 보유 > 보유, 주식 미보유 > 보유 중 최대값
```

여기까지 하다보면 결국 중요한 것은 **i 시점의 마지막에 "주식을 보유하고 있는가"**의 여부와 그 각각 경우에서의 값이 오직 중요한 변수라는 것이 삘이 오게 된다. 오나...? DP는 정말 어려워요...

사실상 마지막에는 hold값이 최대가 될 수 없다. 마지막에 주식을 들고 있는건 같은 시점에서 주식을 판 값보다 무조건 적기 때문에... (cash[i] > hold[i])

그래서 무튼 정답은 아래와 같이 나온다.

```python
class Solution(object):
    def maxProfit(self, prices, fee):
        cash, hold = 0, -prices[0]
        for i in range(1, len(prices)):
            cash = max(cash, hold + prices[i] - fee)
            hold = max(hold, cash - prices[i])
        return cash
```

 DP 문제 간간히 하나씩은 풀어야겠다...